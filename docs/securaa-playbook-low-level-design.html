<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Securaa Playbook Service - Low Level Design - Securaa Platform Documentation</title>
    <link rel="stylesheet" href="assets/css/documentation.css">
</head>
<body>
    <header class="main-header">
        <h1>Securaa Platform Documentation</h1>
        <p>Comprehensive documentation for Securaa security platform services</p>
    </header>
    
    
        <nav class="documentation-nav">
            <ul>
                <li><a href="index.html">Home</a></li>
<li><a href="securaa-playbook-high-level-design.html">Playbook Service</a></li>
<li><a href="securaa-playbook-low-level-design.html">Playbook Service</a></li>
<li><a href="optimization-guide.html">Optimization Guide</a></li>
<li><a href="securaa-siem-high-level-design.html">SIEM Service</a></li>
<li><a href="securaa-platform-high-level-design.html">Securaa Platform</a></li>
<li><a href="process-manager-high-level-design.html">Process Manager</a></li>
<li><a href="process-manager-low-level-design.html">Process Manager</a></li>
<li><a href="securaa-user-high-level-design.html">User Authentication</a></li>
<li><a href="securaa-user-low-level-design.html">User Authentication</a></li>
            </ul>
        </nav>
        
    
    <main class="main-content">
        <h1>Securaa Playbook Service - Low Level Design Document</h1>
<h2>Document Information</h2>
<ul>
<li><strong>Service Name</strong>: Securaa Playbook Service</li>
<li><strong>Version</strong>: 1.0</li>
<li><strong>Date</strong>: September 11, 2025</li>
<li><strong>Author</strong>: Development Team</li>
<li><strong>Related Documents</strong>: <a href="./HIGH_LEVEL_DESIGN.md">High Level Design</a></li>
</ul>
<h2>Table of Contents</h2>
<ol>
<li><a href="#overview">Overview</a></li>
<li><a href="#detailed-component-design">Detailed Component Design</a></li>
<li><a href="#class-diagrams">Class Diagrams</a></li>
<li><a href="#sequence-diagrams">Sequence Diagrams</a></li>
<li><a href="#database-schema">Database Schema</a></li>
<li><a href="#api-specifications">API Specifications</a></li>
<li><a href="#algorithm-specifications">Algorithm Specifications</a></li>
<li><a href="#configuration-management">Configuration Management</a></li>
<li><a href="#error-handling-implementation">Error Handling Implementation</a></li>
<li><a href="#concurrency--thread-safety">Concurrency & Thread Safety</a></li>
<li><a href="#performance-optimizations">Performance Optimizations</a></li>
<li><a href="#testing-strategy">Testing Strategy</a></li>
</ol>
<p>---</p>
<h2>1. Overview</h2>
<p>The Low Level Design document provides detailed implementation specifications for the Securaa Playbook Service, including class structures, method signatures, algorithm implementations, and detailed interaction patterns.</p>
<h3>1.1 Scope</h3>
<p>This document covers:</p>
<ul>
<li>Detailed class and method specifications</li>
<li>Database schema with indexes and constraints</li>
<li>Complete API specifications with validation rules</li>
<li>Concurrency patterns and thread safety mechanisms</li>
<li>Performance optimization techniques</li>
<li>Error handling and recovery strategies</li>
</ul>
<p>---</p>
<h2>2. Detailed Component Design</h2>
<h3>2.1 Core Package Structure</h3>
<pre><code class="language-">zona_services/zona_playbook/
<p>├── main.go                     // Application entry point</p>
<p>├── app.go                      // Application initialization</p>
<p>├── controllers/                // HTTP request handlers</p>
<p>│   ├── playbookcontroller.go</p>
<p>│   ├── listController.go</p>
<p>│   ├── caseController.go</p>
<p>│   ├── supportcontroller.go</p>
<p>│   └── processController.go</p>
<p>├── executionControllers/       // Execution orchestration</p>
<p>│   ├── playbookExecutionController.go</p>
<p>│   ├── runTaskController.go</p>
<p>│   ├── conditionController.go</p>
<p>│   └── subPlaybookController.go</p>
<p>├── models/                     // Data models</p>
<p>│   ├── playbook.go</p>
<p>│   ├── case.go</p>
<p>│   ├── task.go</p>
<p>│   └── Response.go</p>
<p>├── executionModels/           // Execution-specific models</p>
<p>│   ├── playbook.go</p>
<p>│   ├── Tasks.go</p>
<p>│   └── incidents.go</p>
<p>├── services/                  // Business logic</p>
<p>│   ├── genericTaskService.go</p>
<p>│   ├── processService.go</p>
<p>│   └── filterNTransformService.go</p>
<p>├── utils/                     // Utility functions</p>
<p>│   ├── filterConditionUtils.go</p>
<p>│   ├── matchConditionUtils.go</p>
<p>│   └── executionUtils.go</p>
<p>├── handlers/                  // Error and response handlers</p>
<p>│   ├── errorHandler.go</p>
<p>│   └── taskResponse.go</p>
<p>├── constants/                 // Application constants</p>
<p>│   └── constants.go</p>
<p>└── cacheControllers/         // Cache management</p>
<p>    └── cacheController.go</code></pre></p>
<h3>2.2 Main Application Structure</h3>
<h4>2.2.1 App Structure</h4>
<pre><code class="language-go">type App struct {
<p>    Router             <em>mux.Router                    // HTTP router</p>
<p>    AccessTokenHashMap map[string]int64               // Session management</p>
<p>    DBSession          map[string]common.SessionStruct // Database sessions</p>
<p>    ConfigObject       config.ConfigStruct            // Configuration</p>
<p>    BuildType          string                         // Enterprise/MSSP</p>
<p>    LicenseType        string                         // License information</p>
<p>    RequestResponseLog bool                           // Logging flag</p>
<p>    DockerNodeID       string                         // Docker node identifier</p>
<p>}</code></pre></p>
<h4>2.2.2 Initialization Flow</h4>
<pre><code class="language-go">func (a </em>App) Initialize() {
<p>    // 1. Load configuration</p>
<p>    a.ConfigObject = utils.InitConfig()</p>
    
<p>    // 2. Initialize database sessions</p>
<p>    a.InitMongoSession(a.ConfigObject)</p>
    
<p>    // 3. Initialize access token map</p>
<p>    a.AccessTokenHashMap = make(map[string]int64)</p>
    
<p>    // 4. Setup HTTP router</p>
<p>    a.Router = mux.NewRouter()</p>
<p>    a.initializeRoutes()</p>
    
<p>    // 5. Initialize Docker client</p>
<p>    cli, err := client.NewEnvClient()</p>
<p>    a.DockerNodeID, err = docker.GetNodeID(cli)</p>
    
<p>    // 6. Start background services</p>
<p>    go cache.CacheHealthCheck("test")</p>
<p>    go counter.SetMaxActiveTasksUtilsCount(cli, a.ConfigObject, false)</p>
    
<p>    // 7. Update playbook status on startup</p>
<p>    err = controllers.UpdatePlaybookStatus(a.ConfigObject)</p>
<p>}</code></pre></p>
<p>---</p>
<h2>3. Class Diagrams</h2>
<h3>3.1 Playbook Execution Model</h3>
<div class="mermaid">
classDiagram
    class PlaybookExecutionController {
        +PlayBookTasksMap map[int]PlayBookTask
        +MapMutex sync.RWMutex
        +TenantCode string
        +CaseID string
        +PlaybookExecutionID string
        +UserID int
        +UserName string
        +AccessToken string
        +JwtToken string
        +IndicatorValue string
        +Completed bool
        +Stopped bool
        
        +RunSelectedPlaybook() error
        +ReadAndRunPlayBook() error
        +ProcessAndExecuteTask() error
        +WriteTaskMap(int, PlayBookTask)
        +ReadTaskMap(int) PlayBookTask
        +GetCompletionStatus() bool
        +SetCompletionStatus(bool)
        +GetStopStatus() bool
        +SetStopStatus(bool)
    }
    
    class PlayBookTask {
        +TaskID int
        +TaskSeq int
        +Type string
        +TaskName string
        +TaskTag string
        +InputFields []Inputfields
        +NextTask Object
        +PrevTask Object
        +Conditions []PlayBookCondition
        +ConditionOperator string
        +NextTaskOnTrue Object
        +NextTaskOnFalse Object
        +PEID string
        +TenantCode string
        +PlayBookName string
        +IsFirstTask bool
        +Status string
        +HasFlowControl bool
        +ConditionResult bool
        
        +GetTaskData() error
        +UpdatePlayBookErrorStatus() error
        +UpdatePlayBookExecutionStatus() error
        +CreateFailedTaskEntry() error
    }
    
    class PlaybookObject {
        +ID int
        +Name string
        +Description string
        +Definition string
        +ChartDefinition string
        +TenantCode string
        +CategoryID int
        +Status string
        +IsParallelPlaybook bool
        +TotalTasksCount int
        
        +GetPlaybookData() error
        +ImportPlaybook2() error
        +CreateImportedPlaybook() error
    }
    
    PlaybookExecutionController --> PlayBookTask : manages
    PlayBookTask --> PlaybookObject : executes
</div>
<h3>3.2 Task Execution Model</h3>
<div class="mermaid">
classDiagram
    class TaskRequest {
        +TaskObjectID primitive.ObjectID
        +TaskRequestID string
        +TaskID int
        +UserID int
        +PEID string
        +TaskSeq int
        +Input string
        +Response string
        +Processed string
        +CreatedDate int64
        +UpdatedDate int64
        +TasksTag string
        +TenantCode string
        +AlertID int
        +Status string
        +ExecutionStatus string
        
        +CreateTaskRequest() error
    }
    
    class TaskResponse {
        +TaskResponseID int
        +TaskRequestID string
        +Response string
        +TenantCode string
        +CreatedDate int64
        +ApprovalStatus string
        +PlaybookName string
    }
    
    class ActiveInstanceObject {
        +InstanceID int
        +IntegrationID int64
        +TenantCode string
        +Title string
        +Status string
        +Fields Object
        +FieldsMap map[string]Object
        +CredentialsID int
        +BaseURL string
        +IsCustomApp bool
    }
    
    TaskRequest --> TaskResponse : generates
    TaskRequest --> ActiveInstanceObject : uses
</div>
<h3>3.3 Filter & Transform Model</h3>
<div class="mermaid">
classDiagram
    class Inputfields {
        +Name string
        +Label string
        +Type string
        +ID string
        +Required bool
        +MaxLength int
        +Value Object
        +Host string
        +Filters []Filter
        +Transformers []Transformer
        +Item string
    }
    
    class Filter {
        +Field string
        +ConditionTag string
        +Value Object
    }
    
    class Transformer {
        +Name string
        +Data Object
        +Filter Object
    }
    
    class FilterTransformService {
        +TransformValues() Object
        +VerifyFilterCondition() bool
        +GetFieldValue() Object
        +MatchCondition() bool
    }
    
    Inputfields --> Filter : contains
    Inputfields --> Transformer : contains
    FilterTransformService --> Inputfields : processes
</div>
<p>---</p>
<h2>4. Sequence Diagrams</h2>
<h3>4.1 Playbook Execution Flow</h3>
<div class="mermaid">
sequenceDiagram
    participant Client
    participant Router
    participant Controller
    participant ExecutionController
    participant TaskExecutor
    participant Database
    participant ExternalSystem
    
    Client->>Router: POST /runplaybook/
    Router->>Controller: Route request
    Controller->>ExecutionController: RunSelectedPlaybook()
    
    ExecutionController->>Database: Get playbook definition
    Database-->>ExecutionController: Playbook data
    
    ExecutionController->>ExecutionController: ReadAndRunPlayBook()
    ExecutionController->>Database: Create execution entry
    
    loop For each task
        ExecutionController->>TaskExecutor: ProcessAndExecuteTask()
        TaskExecutor->>Database: Get task configuration
        TaskExecutor->>ExternalSystem: Execute task
        ExternalSystem-->>TaskExecutor: Task response
        TaskExecutor->>Database: Save task response
        TaskExecutor-->>ExecutionController: Task completed
    end
    
    ExecutionController->>Database: Update execution status
    ExecutionController-->>Controller: Execution complete
    Controller-->>Router: Response
    Router-->>Client: Final response
</div>
<h3>4.2 Task Execution with Conditions</h3>
<div class="mermaid">
sequenceDiagram
    participant ExecutionController
    participant ConditionProcessor
    participant TaskExecutor
    participant FilterEngine
    participant Database
    
    ExecutionController->>ConditionProcessor: ProcessConditionTask()
    ConditionProcessor->>FilterEngine: EvaluateConditions()
    
    loop For each condition
        FilterEngine->>Database: Get case data
        Database-->>FilterEngine: Field values
        FilterEngine->>FilterEngine: MatchCondition()
    end
    
    FilterEngine-->>ConditionProcessor: Condition result
    
    alt Condition true
        ConditionProcessor->>TaskExecutor: Execute NextTaskOnTrue
    else Condition false
        ConditionProcessor->>TaskExecutor: Execute NextTaskOnFalse
    end
    
    TaskExecutor-->>ExecutionController: Continue execution
</div>
<h3>4.3 Error Handling Flow</h3>
<div class="mermaid">
sequenceDiagram
    participant TaskExecutor
    participant ErrorHandler
    participant Database
    participant NotificationService
    
    TaskExecutor->>TaskExecutor: Execute task
    
    alt Task fails
        TaskExecutor->>ErrorHandler: HandleTaskError()
        ErrorHandler->>Database: Log error details
        ErrorHandler->>Database: Update execution status
        ErrorHandler->>NotificationService: Send failure notification
        
        alt Recoverable error
            ErrorHandler->>TaskExecutor: Retry with backoff
        else Non-recoverable error
            ErrorHandler->>Database: Mark execution as failed
        end
    end
</div>
<p>---</p>
<h2>5. Database Schema</h2>
<h3>5.1 MongoDB Collections Schema</h3>
<h4>5.1.1 Playbook Collection</h4>
<pre><code class="language-javascript">{
<p>  "_id": ObjectId,</p>
<p>  "id": 1001,                           // Auto-increment ID</p>
<p>  "name": "Malware Response Playbook",   // Unique per tenant</p>
<p>  "description": "Automated malware response workflow",</p>
<p>  "version": "1.0.0",</p>
<p>  "definition": "...",                   // JSON string of task definitions</p>
<p>  "chart_definition": "...",             // Visual representation</p>
<p>  "tenant_code": "tenant123",</p>
<p>  "category_id": 5,</p>
<p>  "status": "active",                    // active, draft, archived</p>
<p>  "created_date": 1694443200000,</p>
<p>  "updated_date": 1694443200000,</p>
<p>  "user_id": 1001,</p>
<p>  "group_id": 100,</p>
<p>  "type": "case",                        // case, indicator</p>
<p>  "filename": "1001_tenant123.json",</p>
<p>  "commit_id": "abc123",</p>
<p>  "list_names": ["suspicious_ips", "malware_domains"],</p>
<p>  "all_nodes_connected": "yes",</p>
<p>  "custom_utils_added": false,</p>
<p>  "custom_utils_names": [],</p>
<p>  "vertical_pb": false,</p>
<p>  "is_parallel_playbook": true,</p>
<p>  "total_tasks_count": 15,</p>
<p>  "total_utils_count": 3,</p>
<p>  "shard_bucket": 1                      // For sharding</p>
<p>}</p>
<p>// Indexes</p>
<p>db.playbook_collection.createIndex({"tenant_code": 1, "name": 1}, {unique: true})</p>
<p>db.playbook_collection.createIndex({"tenant_code": 1, "status": 1})</p>
<p>db.playbook_collection.createIndex({"category_id": 1, "status": 1})</p>
<p>db.playbook_collection.createIndex({"shard_bucket": 1})</code></pre></p>
<h4>5.1.2 Playbook Execution Collection</h4>
<pre><code class="language-javascript">{
<p>  "_id": ObjectId,</p>
<p>  "id": "pb_exec_123456",                // Execution ID</p>
<p>  "parent_playbook_execution_id": "pb_exec_123455",</p>
<p>  "pid": 1001,                           // Playbook ID</p>
<p>  "uid": 2001,                           // User ID</p>
<p>  "request_data": "...",                 // Original request</p>
<p>  "tenant_code": "tenant123",</p>
<p>  "alert_id": 50001,                     // Case/Incident ID</p>
<p>  "is_evidence": "n",</p>
<p>  "created_date": 1694443200000,</p>
<p>  "status": "active",</p>
<p>  "execution_status": "inprogress",      // inprogress, completed, failed, stopped</p>
<p>  "execution_completion_time": 1694443500000,</p>
<p>  "execution_error_msg": "",</p>
<p>  "execution_error_path": "",</p>
<p>  "username": "security_analyst",</p>
<p>  "indicator": "192.168.1.100",</p>
<p>  "playbook_stopped_manually": false,</p>
<p>  "stop_playbook_data": {</p>
<p>    "sub_playbook_execution_id": "pb_exec_sub_001"</p>
<p>  },</p>
<p>  "last_executed_task_seq": 5,</p>
<p>  "total_tasks_count": 15,</p>
<p>  "total_utils_count": 3,</p>
<p>  "playbook_name": "Malware Response",</p>
<p>  "playbook_runtime": 45000,             // milliseconds</p>
<p>  "source": "ui",                        // ui, api, scheduled</p>
<p>  "node_id": "docker_node_1",</p>
<p>  "shard_bucket": 1</p>
<p>}</p>
<p>// Indexes</p>
<p>db.playbook_execution_collection.createIndex({"tenant_code": 1, "alert_id": 1})</p>
<p>db.playbook_execution_collection.createIndex({"execution_status": 1, "created_date": -1})</p>
<p>db.playbook_execution_collection.createIndex({"uid": 1, "created_date": -1})</p>
<p>db.playbook_execution_collection.createIndex({"shard_bucket": 1})</code></pre></p>
<h4>5.1.3 Task Execution Collection</h4>
<pre><code class="language-javascript">{
<p>  "_id": ObjectId,</p>
<p>  "task_request_id": "task_req_789012",</p>
<p>  "description": "Block malicious IP",</p>
<p>  "logo_path": "lib/logo/firewall.png",</p>
<p>  "tenant_code": "tenant123",</p>
<p>  "name": "Block IP Address",</p>
<p>  "app_name": "Palo Alto Firewall",</p>
<p>  "task_id": 301,</p>
<p>  "user_id": 2001,</p>
<p>  "username": "security_analyst",</p>
<p>  "input": "...",                        // Serialized input data</p>
<p>  "processed": "y",                      // y, n</p>
<p>  "created_date": 1694443200000,</p>
<p>  "updated_date": 1694443300000,</p>
<p>  "tasks_tag": "palo_alto_block_ip",</p>
<p>  "rest_url": "https://firewall.api/block",</p>
<p>  "method": "POST",</p>
<p>  "alert_id": 50001,</p>
<p>  "integration_id": 15,</p>
<p>  "instance_id": 150,</p>
<p>  "task_handler": "palo_alto",</p>
<p>  "response": "...",                     // Serialized response</p>
<p>  "is_demo": false,</p>
<p>  "peid": "pb_exec_123456",              // Playbook execution ID</p>
<p>  "task_peid": "",                       // Sub-playbook execution ID</p>
<p>  "task_seq": 3,</p>
<p>  "is_condition": "n",</p>
<p>  "task_condition": "",</p>
<p>  "condition_operator": "",</p>
<p>  "is_evidence": "n",</p>
<p>  "status": "completed",                 // not_started, inprogress, completed, failed</p>
<p>  "playbook_id": "1001",</p>
<p>  "instance_name": "Production Firewall",</p>
<p>  "indicator_type": "ip",</p>
<p>  "task_response_time_stamp": 1694443300000,</p>
<p>  "reputation": "malicious",</p>
<p>  "category": "network_security",</p>
<p>  "function_name": "block_ip_address",</p>
<p>  "filename": "palo_alto_tasks.py",</p>
<p>  "credentials_required": true,</p>
<p>  "task_operator_id": "op_001",</p>
<p>  "indicator": "192.168.1.100",</p>
<p>  "case_description": "Malware infection detected",</p>
<p>  "type": "integration",</p>
<p>  "command": "",</p>
<p>  "generic": false,</p>
<p>  "headers": {</p>
<p>    "Content-Type": "application/json",</p>
<p>    "Authorization": "Bearer token123"</p>
<p>  },</p>
<p>  "content_type": "application/json",</p>
<p>  "request_body": "...",</p>
<p>  "request_type": "POST",</p>
<p>  "task_type": "blocking",</p>
<p>  "custom_task_name": "",</p>
<p>  "playbook_name": "Malware Response",</p>
<p>  "node_id": "docker_node_1",</p>
<p>  "iterate_task": false,</p>
<p>  "iteration_config": "",</p>
<p>  "execution_status": "completed",</p>
<p>  "shard_bucket": 1</p>
<p>}</p>
<p>// Indexes</p>
<p>db.task_execution_collection.createIndex({"peid": 1, "task_seq": 1})</p>
<p>db.task_execution_collection.createIndex({"tenant_code": 1, "alert_id": 1})</p>
<p>db.task_execution_collection.createIndex({"processed": 1, "created_date": 1})</p>
<p>db.task_execution_collection.createIndex({"shard_bucket": 1})</code></pre></p>
<h4>5.1.4 Stopped Tasks Collection</h4>
<pre><code class="language-javascript">{
<p>  "_id": ObjectId,</p>
<p>  "case_id": "50001",</p>
<p>  "peid": "pb_exec_123456",</p>
<p>  "task_seq": 5,</p>
<p>  "routine": "MAIN",                     // MAIN, SUB</p>
<p>  "task_name": "Block IP Address",</p>
<p>  "status": "stopped"                    // stopped, resumed</p>
<p>}</p>
<p>// Indexes</p>
<p>db.stopped_tasks_collection.createIndex({"peid": 1, "case_id": 1, "status": 1})</code></pre></p>
<h3>5.2 Data Relationships</h3>
<div class="mermaid">
erDiagram
    PLAYBOOK_COLLECTION ||--o{ PLAYBOOK_EXECUTION_COLLECTION : "executes"
    PLAYBOOK_EXECUTION_COLLECTION ||--o{ TASK_EXECUTION_COLLECTION : "contains"
    PLAYBOOK_EXECUTION_COLLECTION ||--o{ STOPPED_TASKS_COLLECTION : "may_have"
    INCIDENTS_COLLECTION ||--o{ PLAYBOOK_EXECUTION_COLLECTION : "triggers"
    TASK_COLLECTION ||--o{ TASK_EXECUTION_COLLECTION : "defines"
    INTEGRATION_COLLECTION ||--o{ TASK_EXECUTION_COLLECTION : "provides"
    INSTANCE_COLLECTION ||--o{ TASK_EXECUTION_COLLECTION : "executes_on"
</div>
<p>---</p>
<h2>6. API Specifications</h2>
<h3>6.1 Playbook Management APIs</h3>
<h4>6.1.1 Create Playbook</h4>
<pre><code class="language-http">POST /createplaybook/
<p>Content-Type: application/json</p>
<p>Authorization: Bearer {jwt_token}</p>
<p>Request Body:</p>
<p>{</p>
<p>  "name": "Malware Response Playbook",</p>
<p>  "description": "Automated response to malware incidents",</p>
<p>  "definition": "...",                    // JSON string</p>
<p>  "chart_definition": "...",              // Visual representation</p>
<p>  "category_id": 5,</p>
<p>  "type": "case",</p>
<p>  "tenant_code": "tenant123",</p>
<p>  "user_id": 1001,</p>
<p>  "version": "1.0.0",</p>
<p>  "is_parallel_playbook": true,</p>
<p>  "total_tasks_count": 15,</p>
<p>  "total_utils_count": 3</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>  "success": true,</p>
<p>  "data": {</p>
<p>    "playbook_id": 1001,</p>
<p>    "filename": "1001_tenant123.json",</p>
<p>    "commit_id": "abc123"</p>
<p>  },</p>
<p>  "error": "",</p>
<p>  "displayMessage": "Playbook created successfully",</p>
<p>  "time": 1694443200000</p>
<p>}</p>
<p>Validation Rules:</p>
<ul>
<li>name: Required, max 255 chars, unique per tenant</li>
<li>description: Optional, max 1000 chars</li>
<li>definition: Required, valid JSON</li>
<li>category_id: Required, must exist</li>
<li>type: Required, enum [case, indicator]</li>
<li>tenant_code: Required, valid tenant</li>
<li>user_id: Required, valid user</code></pre></li>
</ul>
<h4>6.1.2 Run Playbook</h4>
<pre><code class="language-http">POST /runplaybook/
<p>Content-Type: application/json</p>
<p>Authorization: Bearer {jwt_token}</p>
<p>Request Body:</p>
<p>{</p>
<p>  "tenantcode": "tenant123",</p>
<p>  "playbook_name": "Malware Response Playbook",</p>
<p>  "case_id": "50001",</p>
<p>  "is_bot": "false",</p>
<p>  "uid": "1001",</p>
<p>  "username": "security_analyst",</p>
<p>  "type": "case",</p>
<p>  "indicator": "192.168.1.100",</p>
<p>  "playbook_execution_id": "",           // For resume</p>
<p>  "resume_playbook": "false"</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>  "success": true,</p>
<p>  "data": {</p>
<p>    "playbook_execution_id": "pb_exec_123456",</p>
<p>    "status": "inprogress",</p>
<p>    "total_tasks": 15,</p>
<p>    "estimated_duration": 300000         // milliseconds</p>
<p>  },</p>
<p>  "error": "",</p>
<p>  "displayMessage": "Playbook execution started",</p>
<p>  "time": 1694443200000</p>
<p>}</p>
<p>Validation Rules:</p>
<ul>
<li>tenantcode: Required, valid tenant</li>
<li>playbook_name: Required, must exist and be active</li>
<li>case_id: Required for type=case</li>
<li>uid: Required, valid user</li>
<li>type: Required, enum [case, indicator]</li>
<li>indicator: Required for type=indicator</code></pre></li>
</ul>
<h3>6.2 Task Management APIs</h3>
<h4>6.2.1 Run Single Task</h4>
<pre><code class="language-http">POST /runtask/
<p>Content-Type: application/json</p>
<p>Authorization: Bearer {jwt_token}</p>
<p>Request Body:</p>
<p>{</p>
<p>  "task_id": 301,</p>
<p>  "tenant_code": "tenant123",</p>
<p>  "case_id": 50001,</p>
<p>  "user_id": 1001,</p>
<p>  "input_fields": [</p>
<p>    {</p>
<p>      "name": "ip_address",</p>
<p>      "value": "192.168.1.100",</p>
<p>      "type": "string"</p>
<p>    }</p>
<p>  ],</p>
<p>  "instance_id": 150,</p>
<p>  "is_demo": false</p>
<p>}</p>
<p>Response:</p>
<p>{</p>
<p>  "success": true,</p>
<p>  "data": {</p>
<p>    "task_request_id": "task_req_789012",</p>
<p>    "status": "inprogress"</p>
<p>  },</p>
<p>  "error": "",</p>
<p>  "displayMessage": "Task execution started",</p>
<p>  "time": 1694443200000</p>
<p>}</code></pre></p>
<h3>6.3 Error Response Format</h3>
<pre><code class="language-json">{
<p>  "success": false,</p>
<p>  "data": null,</p>
<p>  "error": "Invalid playbook configuration",</p>
<p>  "displayMessage": "The playbook contains invalid task definitions",</p>
<p>  "errorPath": "ExecutionController.ProcessAndExecuteTask",</p>
<p>  "status": "failed",</p>
<p>  "time": 1694443200000</p>
<p>}</code></pre></p>
<p>---</p>
<h2>7. Algorithm Specifications</h2>
<h3>7.1 Parallel Task Execution Algorithm</h3>
<pre><code class="language-go">func (executionController <em>PlaybookExecutionController) executeParallelTasks(
<p>    tasks []executionModels.PlayBookTask,</p>
<p>    dockerNodeID string,</p>
<p>    mongodbSession mongo_driver.MongoClientWrapper,</p>
<p>    coreMongodbSession mongo_driver.MongoClientWrapper,</p>
<p>    configObject config.ConfigStruct,</p>
<p>    dbSession map[string]common.SessionStruct,</p>
<p>) error {</p>
    
<p>    var wg sync.WaitGroup</p>
<p>    var mutex sync.Mutex</p>
<p>    errorChan := make(chan error, len(tasks))</p>
<p>    panicChan := make(chan interface{}, len(tasks))</p>
<p>    ctx, cancel := context.WithCancel(context.Background())</p>
<p>    defer cancel()</p>
    
<p>    // Create stop lookup channel</p>
<p>    stopLookup := make(chan bool, 1)</p>
<p>    var lookupWg sync.WaitGroup</p>
<p>    lookupWg.Add(1)</p>
    
<p>    // Start stop lookup goroutine</p>
<p>    go func() {</p>
<p>        defer lookupWg.Done()</p>
<p>        ticker := time.NewTicker(2 </em> time.Second)</p>
<p>        defer ticker.Stop()</p>
        
<p>        for {</p>
<p>            select {</p>
<p>            case <-stopLookup:</p>
<p>                return</p>
<p>            case <-ticker.C:</p>
<p>                // Check if playbook should be stopped</p>
<p>                if executionController.checkStopCondition() {</p>
<p>                    cancel()</p>
<p>                    return</p>
<p>                }</p>
<p>            }</p>
<p>        }</p>
<p>    }()</p>
    
<p>    // Execute tasks in parallel</p>
<p>    for i, task := range tasks {</p>
<p>        wg.Add(1)</p>
<p>        go func(taskIndex int, t executionModels.PlayBookTask) {</p>
<p>            defer wg.Done()</p>
<p>            defer func() {</p>
<p>                if r := recover(); r != nil {</p>
<p>                    panicChan <- r</p>
<p>                }</p>
<p>            }()</p>
            
<p>            select {</p>
<p>            case <-ctx.Done():</p>
<p>                // Context cancelled, stop execution</p>
<p>                return</p>
<p>            default:</p>
<p>                // Execute task</p>
<p>                err := executionController.ProcessAndExecuteTask(</p>
<p>                    t.TaskSeq,</p>
<p>                    dockerNodeID,</p>
<p>                    mongodbSession,</p>
<p>                    coreMongodbSession,</p>
<p>                    configObject,</p>
<p>                    dbSession,</p>
<p>                    &wg,</p>
<p>                    "PARALLEL",</p>
<p>                    ctx,</p>
<p>                    panicChan,</p>
<p>                )</p>
                
<p>                if err != nil {</p>
<p>                    mutex.Lock()</p>
<p>                    select {</p>
<p>                    case errorChan <- err:</p>
<p>                    default:</p>
<p>                    }</p>
<p>                    mutex.Unlock()</p>
                    
<p>                    if t.StopOnError {</p>
<p>                        cancel() // Stop all parallel tasks</p>
<p>                    }</p>
<p>                }</p>
<p>            }</p>
<p>        }(i, task)</p>
<p>    }</p>
    
<p>    // Wait for all tasks to complete</p>
<p>    wg.Wait()</p>
    
<p>    // Stop the lookup goroutine</p>
<p>    close(stopLookup)</p>
<p>    lookupWg.Wait()</p>
    
<p>    // Check for errors</p>
<p>    close(errorChan)</p>
<p>    for err := range errorChan {</p>
<p>        if err != nil {</p>
<p>            return err</p>
<p>        }</p>
<p>    }</p>
    
<p>    // Check for panics</p>
<p>    close(panicChan)</p>
<p>    for panic := range panicChan {</p>
<p>        if panic != nil {</p>
<p>            return fmt.Errorf("panic in task execution: %v", panic)</p>
<p>        }</p>
<p>    }</p>
    
<p>    return nil</p>
<p>}</code></pre></p>
<h3>7.2 Condition Evaluation Algorithm</h3>
<pre><code class="language-go">func (cc <em>ConditionController) evaluateConditions(
<p>    conditions []executionModels.PlayBookCondition,</p>
<p>    conditionOperator string,</p>
<p>    alertData models.RunPlayBookRequest2,</p>
<p>    executedConditions []executionModels.ExecutedConditionStatus,</p>
<p>) (bool, error) {</p>
    
<p>    if len(conditions) == 0 {</p>
<p>        return true, nil</p>
<p>    }</p>
    
<p>    var results []bool</p>
    
<p>    for _, condition := range conditions {</p>
<p>        result, err := cc.evaluateSingleCondition(</p>
<p>            condition,</p>
<p>            alertData,</p>
<p>            executedConditions,</p>
<p>        )</p>
<p>        if err != nil {</p>
<p>            return false, err</p>
<p>        }</p>
<p>        results = append(results, result)</p>
<p>    }</p>
    
<p>    // Apply logical operator</p>
<p>    switch strings.ToLower(conditionOperator) {</p>
<p>    case "and":</p>
<p>        return cc.applyAndOperator(results), nil</p>
<p>    case "or":</p>
<p>        return cc.applyOrOperator(results), nil</p>
<p>    default:</p>
<p>        return false, fmt.Errorf("unsupported condition operator: %s", conditionOperator)</p>
<p>    }</p>
<p>}</p>
<p>func (cc </em>ConditionController) evaluateSingleCondition(</p>
<p>    condition executionModels.PlayBookCondition,</p>
<p>    alertData models.RunPlayBookRequest2,</p>
<p>    executedConditions []executionModels.ExecutedConditionStatus,</p>
<p>) (bool, error) {</p>
    
<p>    // Get field value from case data or previous task response</p>
<p>    var fieldValue interface{}</p>
<p>    var err error</p>
    
<p>    if condition.ConditionKeyValue != nil {</p>
<p>        // Static value condition</p>
<p>        fieldValue = condition.ConditionKeyValue</p>
<p>    } else if condition.TaskName != "" {</p>
<p>        // Previous task response condition</p>
<p>        fieldValue, err = cc.getPreviousTaskResponse(</p>
<p>            condition.TaskName,</p>
<p>            condition.ConditionKey,</p>
<p>            executedConditions,</p>
<p>        )</p>
<p>        if err != nil {</p>
<p>            return false, err</p>
<p>        }</p>
<p>    } else {</p>
<p>        // Case field condition</p>
<p>        fieldValue = utils.GetFieldValue(alertData, condition.ConditionKey)</p>
<p>    }</p>
    
<p>    // Evaluate condition</p>
<p>    return utils.MatchCondition(</p>
<p>        fieldValue,</p>
<p>        condition.ConditionType,</p>
<p>        condition.ConditionValue,</p>
<p>    )</p>
<p>}</p>
<p>func (cc <em>ConditionController) applyAndOperator(results []bool) bool {</p>
<p>    for _, result := range results {</p>
<p>        if !result {</p>
<p>            return false</p>
<p>        }</p>
<p>    }</p>
<p>    return true</p>
<p>}</p>
<p>func (cc </em>ConditionController) applyOrOperator(results []bool) bool {</p>
<p>    for _, result := range results {</p>
<p>        if result {</p>
<p>            return true</p>
<p>        }</p>
<p>    }</p>
<p>    return false</p>
<p>}</code></pre></p>
<h3>7.3 Cache Management Algorithm</h3>
<pre><code class="language-go">type CacheManager struct {
<p>    redisClient   <em>redis.Client</p>
<p>    localCache    </em>sync.Map</p>
<p>    ttlMap        <em>sync.Map</p>
<p>    mutex         sync.RWMutex</p>
<p>    cleanupTicker </em>time.Ticker</p>
<p>}</p>
<p>func (cm <em>CacheManager) Get(key string) (interface{}, bool) {</p>
<p>    cm.mutex.RLock()</p>
<p>    defer cm.mutex.RUnlock()</p>
    
<p>    // Check local cache first</p>
<p>    if value, exists := cm.localCache.Load(key); exists {</p>
<p>        // Check TTL</p>
<p>        if ttl, ok := cm.ttlMap.Load(key); ok {</p>
<p>            if time.Now().Unix() > ttl.(int64) {</p>
<p>                cm.localCache.Delete(key)</p>
<p>                cm.ttlMap.Delete(key)</p>
<p>                return nil, false</p>
<p>            }</p>
<p>            return value, true</p>
<p>        }</p>
<p>    }</p>
    
<p>    // Fall back to Redis</p>
<p>    result, err := cm.redisClient.Get(key).Result()</p>
<p>    if err != nil {</p>
<p>        return nil, false</p>
<p>    }</p>
    
<p>    // Parse and cache locally</p>
<p>    var value interface{}</p>
<p>    json.Unmarshal([]byte(result), &value)</p>
<p>    cm.localCache.Store(key, value)</p>
    
<p>    return value, true</p>
<p>}</p>
<p>func (cm </em>CacheManager) Set(key string, value interface{}, ttl time.Duration) error {</p>
<p>    cm.mutex.Lock()</p>
<p>    defer cm.mutex.Unlock()</p>
    
<p>    // Store in local cache</p>
<p>    cm.localCache.Store(key, value)</p>
    
<p>    if ttl > 0 {</p>
<p>        expiryTime := time.Now().Add(ttl).Unix()</p>
<p>        cm.ttlMap.Store(key, expiryTime)</p>
<p>    }</p>
    
<p>    // Store in Redis</p>
<p>    data, err := json.Marshal(value)</p>
<p>    if err != nil {</p>
<p>        return err</p>
<p>    }</p>
    
<p>    return cm.redisClient.Set(key, data, ttl).Err()</p>
<p>}</p>
<p>func (cm <em>CacheManager) startCleanupRoutine() {</p>
<p>    cm.cleanupTicker = time.NewTicker(5 </em> time.Minute)</p>
    
<p>    go func() {</p>
<p>        for range cm.cleanupTicker.C {</p>
<p>            now := time.Now().Unix()</p>
<p>            cm.ttlMap.Range(func(key, value interface{}) bool {</p>
<p>                if now > value.(int64) {</p>
<p>                    cm.localCache.Delete(key)</p>
<p>                    cm.ttlMap.Delete(key)</p>
<p>                }</p>
<p>                return true</p>
<p>            })</p>
<p>        }</p>
<p>    }()</p>
<p>}</code></pre></p>
<p>---</p>
<h2>8. Configuration Management</h2>
<h3>8.1 Configuration Structure</h3>
<pre><code class="language-go">type ConfigStruct struct {
<p>    DatabaseConfig    DatabaseConfig    <code>json:"database"</code></p>
<p>    RedisConfig       RedisConfig       <code>json:"redis"</code></p>
<p>    DockerConfig      DockerConfig      <code>json:"docker"</code></p>
<p>    SecurityConfig    SecurityConfig    <code>json:"security"</code></p>
<p>    LoggingConfig     LoggingConfig     <code>json:"logging"</code></p>
<p>    IntegrationConfig IntegrationConfig <code>json:"integration"</code></p>
<p>}</p>
<p>type DatabaseConfig struct {</p>
<p>    MongoURI        string <code>json:"mongo_uri"</code></p>
<p>    DatabaseName    string <code>json:"database_name"</code></p>
<p>    MaxPoolSize     int    <code>json:"max_pool_size"</code></p>
<p>    MinPoolSize     int    <code>json:"min_pool_size"</code></p>
<p>    MaxIdleTime     int    <code>json:"max_idle_time"</code></p>
<p>    ConnectTimeout  int    <code>json:"connect_timeout"</code></p>
<p>    ShardBucketCount int   <code>json:"shard_bucket_count"</code></p>
<p>}</p>
<p>type RedisConfig struct {</p>
<p>    Host            string <code>json:"host"</code></p>
<p>    Port            int    <code>json:"port"</code></p>
<p>    Password        string <code>json:"password"</code></p>
<p>    Database        int    <code>json:"database"</code></p>
<p>    MaxRetries      int    <code>json:"max_retries"</code></p>
<p>    PoolSize        int    <code>json:"pool_size"</code></p>
<p>    IdleTimeout     int    <code>json:"idle_timeout"</code></p>
<p>}</p>
<p>type SecurityConfig struct {</p>
<p>    JWTSecret           string <code>json:"jwt_secret"</code></p>
<p>    SessionTimeout      int    <code>json:"session_timeout"</code></p>
<p>    MaxLoginAttempts    int    <code>json:"max_login_attempts"</code></p>
<p>    PasswordComplexity  bool   <code>json:"password_complexity"</code></p>
<p>    EncryptionKey       string <code>json:"encryption_key"</code></p>
<p>}</code></pre></p>
<h3>8.2 Environment-Based Configuration</h3>
<pre><code class="language-go">func LoadConfiguration() ConfigStruct {
<p>    var config ConfigStruct</p>
    
<p>    // Load from environment variables</p>
<p>    config.DatabaseConfig.MongoURI = getEnvOrDefault("MONGO_URI", "mongodb://localhost:27017")</p>
<p>    config.DatabaseConfig.DatabaseName = getEnvOrDefault("DB_NAME", "zona_playbook")</p>
<p>    config.DatabaseConfig.MaxPoolSize = getEnvIntOrDefault("DB_MAX_POOL_SIZE", 100)</p>
    
<p>    config.RedisConfig.Host = getEnvOrDefault("REDIS_HOST", "localhost")</p>
<p>    config.RedisConfig.Port = getEnvIntOrDefault("REDIS_PORT", 6379)</p>
<p>    config.RedisConfig.Password = getEnvOrDefault("REDIS_PASSWORD", "")</p>
    
<p>    config.SecurityConfig.JWTSecret = getEnvOrDefault("JWT_SECRET", "")</p>
<p>    config.SecurityConfig.SessionTimeout = getEnvIntOrDefault("SESSION_TIMEOUT", 3600)</p>
    
<p>    // Load from config file if exists</p>
<p>    if configFile := os.Getenv("CONFIG_FILE"); configFile != "" {</p>
<p>        loadFromFile(&config, configFile)</p>
<p>    }</p>
    
<p>    // Validate configuration</p>
<p>    if err := validateConfig(config); err != nil {</p>
<p>        log.Fatal("Invalid configuration:", err)</p>
<p>    }</p>
    
<p>    return config</p>
<p>}</p>
<p>func validateConfig(config ConfigStruct) error {</p>
<p>    if config.DatabaseConfig.MongoURI == "" {</p>
<p>        return errors.New("mongo_uri is required")</p>
<p>    }</p>
    
<p>    if config.SecurityConfig.JWTSecret == "" {</p>
<p>        return errors.New("jwt_secret is required")</p>
<p>    }</p>
    
<p>    if config.DatabaseConfig.MaxPoolSize <= 0 {</p>
<p>        return errors.New("max_pool_size must be positive")</p>
<p>    }</p>
    
<p>    return nil</p>
<p>}</code></pre></p>
<p>---</p>
<h2>9. Error Handling Implementation</h2>
<h3>9.1 Error Types and Hierarchy</h3>
<pre><code class="language-go">type ErrorType string
<p>const (</p>
<p>    ValidationError    ErrorType = "VALIDATION_ERROR"</p>
<p>    DatabaseError      ErrorType = "DATABASE_ERROR"</p>
<p>    IntegrationError   ErrorType = "INTEGRATION_ERROR"</p>
<p>    AuthenticationError ErrorType = "AUTHENTICATION_ERROR"</p>
<p>    AuthorizationError ErrorType = "AUTHORIZATION_ERROR"</p>
<p>    BusinessLogicError ErrorType = "BUSINESS_LOGIC_ERROR"</p>
<p>    SystemError        ErrorType = "SYSTEM_ERROR"</p>
<p>    NetworkError       ErrorType = "NETWORK_ERROR"</p>
<p>)</p>
<p>type ServiceError struct {</p>
<p>    Type        ErrorType <code>json:"type"</code></p>
<p>    Code        string    <code>json:"code"</code></p>
<p>    Message     string    <code>json:"message"</code></p>
<p>    Details     string    <code>json:"details"</code></p>
<p>    Timestamp   int64     <code>json:"timestamp"</code></p>
<p>    RequestID   string    <code>json:"request_id"</code></p>
<p>    UserID      int       <code>json:"user_id"</code></p>
<p>    TenantCode  string    <code>json:"tenant_code"</code></p>
<p>    StackTrace  string    <code>json:"stack_trace,omitempty"</code></p>
<p>    Cause       error     <code>json:"-"</code></p>
<p>}</p>
<p>func (e <em>ServiceError) Error() string {</p>
<p>    return fmt.Sprintf("[%s] %s: %s", e.Type, e.Code, e.Message)</p>
<p>}</p>
<p>func NewServiceError(errorType ErrorType, code string, message string) </em>ServiceError {</p>
<p>    return &ServiceError{</p>
<p>        Type:      errorType,</p>
<p>        Code:      code,</p>
<p>        Message:   message,</p>
<p>        Timestamp: time.Now().UnixMilli(),</p>
<p>    }</p>
<p>}</code></pre></p>
<h3>9.2 Error Handler Implementation</h3>
<pre><code class="language-go">func HandleError(err error, context string) models.Response {
<p>    var response models.Response</p>
<p>    response.Success = false</p>
<p>    response.Time = time.Now().UnixMilli()</p>
    
<p>    if serviceErr, ok := err.(<em>ServiceError); ok {</p>
<p>        response.Error = serviceErr.Message</p>
<p>        response.ErrorPath = context</p>
<p>        response.Status = string(serviceErr.Type)</p>
        
<p>        // Log structured error</p>
<p>        logger.Error("Service Error", </p>
<p>            "type", serviceErr.Type,</p>
<p>            "code", serviceErr.Code,</p>
<p>            "message", serviceErr.Message,</p>
<p>            "context", context,</p>
<p>            "timestamp", serviceErr.Timestamp,</p>
<p>        )</p>
        
<p>        // Determine appropriate HTTP status</p>
<p>        switch serviceErr.Type {</p>
<p>        case ValidationError:</p>
<p>            response.DisplayMessage = "Invalid input provided"</p>
<p>        case AuthenticationError:</p>
<p>            response.DisplayMessage = "Authentication required"</p>
<p>        case AuthorizationError:</p>
<p>            response.DisplayMessage = "Access denied"</p>
<p>        case DatabaseError:</p>
<p>            response.DisplayMessage = "Data operation failed"</p>
<p>        case IntegrationError:</p>
<p>            response.DisplayMessage = "External service unavailable"</p>
<p>        default:</p>
<p>            response.DisplayMessage = "An unexpected error occurred"</p>
<p>        }</p>
<p>    } else {</p>
<p>        // Handle generic errors</p>
<p>        response.Error = err.Error()</p>
<p>        response.ErrorPath = context</p>
<p>        response.Status = "error"</p>
<p>        response.DisplayMessage = "An unexpected error occurred"</p>
        
<p>        logger.Error("Unhandled Error", </p>
<p>            "error", err.Error(),</p>
<p>            "context", context,</p>
<p>        )</p>
<p>    }</p>
    
<p>    return response</p>
<p>}</code></pre></p>
<h3>9.3 Retry Mechanism</h3>
<pre><code class="language-go">type RetryConfig struct {
<p>    MaxAttempts   int           <code>json:"max_attempts"</code></p>
<p>    InitialDelay  time.Duration <code>json:"initial_delay"</code></p>
<p>    MaxDelay      time.Duration <code>json:"max_delay"</code></p>
<p>    BackoffFactor float64       <code>json:"backoff_factor"</code></p>
<p>    RetryableErrors []ErrorType <code>json:"retryable_errors"</code></p>
<p>}</p>
<p>func RetryWithBackoff(</p>
<p>    operation func() error,</p>
<p>    config RetryConfig,</p>
<p>) error {</p>
<p>    var lastErr error</p>
<p>    delay := config.InitialDelay</p>
    
<p>    for attempt := 1; attempt <= config.MaxAttempts; attempt++ {</p>
<p>        err := operation()</p>
<p>        if err == nil {</p>
<p>            return nil</p>
<p>        }</p>
        
<p>        lastErr = err</p>
        
<p>        // Check if error is retryable</p>
<p>        if serviceErr, ok := err.(</em>ServiceError); ok {</p>
<p>            retryable := false</p>
<p>            for _, retryableType := range config.RetryableErrors {</p>
<p>                if serviceErr.Type == retryableType {</p>
<p>                    retryable = true</p>
<p>                    break</p>
<p>                }</p>
<p>            }</p>
<p>            if !retryable {</p>
<p>                return err</p>
<p>            }</p>
<p>        }</p>
        
<p>        if attempt < config.MaxAttempts {</p>
<p>            logger.Warn("Operation failed, retrying",</p>
<p>                "attempt", attempt,</p>
<p>                "max_attempts", config.MaxAttempts,</p>
<p>                "delay", delay,</p>
<p>                "error", err.Error(),</p>
<p>            )</p>
            
<p>            time.Sleep(delay)</p>
            
<p>            // Calculate next delay with exponential backoff</p>
<p>            delay = time.Duration(float64(delay) <em> config.BackoffFactor)</p>
<p>            if delay > config.MaxDelay {</p>
<p>                delay = config.MaxDelay</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
    
<p>    return fmt.Errorf("operation failed after %d attempts: %w", </p>
<p>        config.MaxAttempts, lastErr)</p>
<p>}</code></pre></p>
<p>---</p>
<h2>10. Concurrency & Thread Safety</h2>
<h3>10.1 Task Map Thread Safety</h3>
<pre><code class="language-go">type ThreadSafeTaskMap struct {
<p>    tasks map[int]executionModels.PlayBookTask</p>
<p>    mutex sync.RWMutex</p>
<p>}</p>
<p>func NewThreadSafeTaskMap() </em>ThreadSafeTaskMap {</p>
<p>    return &ThreadSafeTaskMap{</p>
<p>        tasks: make(map[int]executionModels.PlayBookTask),</p>
<p>    }</p>
<p>}</p>
<p>func (tsm <em>ThreadSafeTaskMap) Set(taskSeq int, task executionModels.PlayBookTask) {</p>
<p>    tsm.mutex.Lock()</p>
<p>    defer tsm.mutex.Unlock()</p>
<p>    tsm.tasks[taskSeq] = task</p>
<p>}</p>
<p>func (tsm </em>ThreadSafeTaskMap) Get(taskSeq int) (executionModels.PlayBookTask, bool) {</p>
<p>    tsm.mutex.RLock()</p>
<p>    defer tsm.mutex.RUnlock()</p>
<p>    task, exists := tsm.tasks[taskSeq]</p>
<p>    return task, exists</p>
<p>}</p>
<p>func (tsm <em>ThreadSafeTaskMap) GetAll() map[int]executionModels.PlayBookTask {</p>
<p>    tsm.mutex.RLock()</p>
<p>    defer tsm.mutex.RUnlock()</p>
    
<p>    // Create a copy to avoid external modifications</p>
<p>    copy := make(map[int]executionModels.PlayBookTask)</p>
<p>    for k, v := range tsm.tasks {</p>
<p>        copy[k] = v</p>
<p>    }</p>
<p>    return copy</p>
<p>}</p>
<p>func (tsm </em>ThreadSafeTaskMap) Delete(taskSeq int) {</p>
<p>    tsm.mutex.Lock()</p>
<p>    defer tsm.mutex.Unlock()</p>
<p>    delete(tsm.tasks, taskSeq)</p>
<p>}</code></pre></p>
<h3>10.2 Channel-Based Communication</h3>
<pre><code class="language-go">type TaskChannel struct {
<p>    taskQueue    chan executionModels.PlayBookTask</p>
<p>    resultQueue  chan TaskResult</p>
<p>    errorQueue   chan error</p>
<p>    stopSignal   chan struct{}</p>
<p>    workerCount  int</p>
<p>    wg           sync.WaitGroup</p>
<p>}</p>
<p>type TaskResult struct {</p>
<p>    TaskSeq  int</p>
<p>    Success  bool</p>
<p>    Response string</p>
<p>    Error    error</p>
<p>}</p>
<p>func NewTaskChannel(bufferSize, workerCount int) <em>TaskChannel {</p>
<p>    return &TaskChannel{</p>
<p>        taskQueue:   make(chan executionModels.PlayBookTask, bufferSize),</p>
<p>        resultQueue: make(chan TaskResult, bufferSize),</p>
<p>        errorQueue:  make(chan error, bufferSize),</p>
<p>        stopSignal:  make(chan struct{}),</p>
<p>        workerCount: workerCount,</p>
<p>    }</p>
<p>}</p>
<p>func (tc </em>TaskChannel) Start() {</p>
<p>    for i := 0; i < tc.workerCount; i++ {</p>
<p>        tc.wg.Add(1)</p>
<p>        go tc.worker(i)</p>
<p>    }</p>
<p>}</p>
<p>func (tc <em>TaskChannel) worker(workerID int) {</p>
<p>    defer tc.wg.Done()</p>
    
<p>    for {</p>
<p>        select {</p>
<p>        case task := <-tc.taskQueue:</p>
<p>            result := tc.executeTask(task)</p>
<p>            tc.resultQueue <- result</p>
            
<p>        case <-tc.stopSignal:</p>
<p>            logger.Info("Worker stopping", "worker_id", workerID)</p>
<p>            return</p>
<p>        }</p>
<p>    }</p>
<p>}</p>
<p>func (tc </em>TaskChannel) SubmitTask(task executionModels.PlayBookTask) {</p>
<p>    select {</p>
<p>    case tc.taskQueue <- task:</p>
<p>        // Task submitted successfully</p>
<p>    case <-time.After(5 <em> time.Second):</p>
<p>        logger.Error("Task submission timeout", "task_seq", task.TaskSeq)</p>
<p>    }</p>
<p>}</p>
<p>func (tc </em>TaskChannel) Stop() {</p>
<p>    close(tc.stopSignal)</p>
<p>    tc.wg.Wait()</p>
<p>    close(tc.taskQueue)</p>
<p>    close(tc.resultQueue)</p>
<p>    close(tc.errorQueue)</p>
<p>}</code></pre></p>
<h3>10.3 Context-Based Cancellation</h3>
<pre><code class="language-go">func (executionController <em>PlaybookExecutionController) ProcessWithContext(
<p>    ctx context.Context,</p>
<p>    task executionModels.PlayBookTask,</p>
<p>) error {</p>
    
<p>    // Create a derived context with timeout</p>
<p>    taskCtx, cancel := context.WithTimeout(ctx, 5</em>time.Minute)</p>
<p>    defer cancel()</p>
    
<p>    // Create result channel</p>
<p>    resultChan := make(chan error, 1)</p>
    
<p>    // Execute task in goroutine</p>
<p>    go func() {</p>
<p>        defer func() {</p>
<p>            if r := recover(); r != nil {</p>
<p>                resultChan <- fmt.Errorf("task panicked: %v", r)</p>
<p>            }</p>
<p>        }()</p>
        
<p>        err := executionController.executeTaskInternal(taskCtx, task)</p>
<p>        resultChan <- err</p>
<p>    }()</p>
    
<p>    // Wait for completion or cancellation</p>
<p>    select {</p>
<p>    case err := <-resultChan:</p>
<p>        return err</p>
        
<p>    case <-taskCtx.Done():</p>
<p>        if taskCtx.Err() == context.DeadlineExceeded {</p>
<p>            return NewServiceError(SystemError, "TASK_TIMEOUT", </p>
<p>                fmt.Sprintf("Task %d timed out", task.TaskSeq))</p>
<p>        }</p>
<p>        return NewServiceError(SystemError, "TASK_CANCELLED", </p>
<p>            fmt.Sprintf("Task %d was cancelled", task.TaskSeq))</p>
<p>    }</p>
<p>}</code></pre></p>
<p>---</p>
<h2>11. Performance Optimizations</h2>
<h3>11.1 Connection Pool Management</h3>
<pre><code class="language-go">type ConnectionPoolManager struct {
<p>    mongoPool   <em>mongo.Client</p>
<p>    redisPool   </em>redis.Client</p>
<p>    httpPool    <em>http.Client</p>
<p>    config      PoolConfig</p>
<p>}</p>
<p>type PoolConfig struct {</p>
<p>    MongoMaxPoolSize    int</p>
<p>    MongoMinPoolSize    int</p>
<p>    MongoMaxIdleTime    time.Duration</p>
<p>    RedisPoolSize       int</p>
<p>    RedisIdleTimeout    time.Duration</p>
<p>    HTTPMaxIdleConns    int</p>
<p>    HTTPIdleConnTimeout time.Duration</p>
<p>}</p>
<p>func NewConnectionPoolManager(config PoolConfig) </em>ConnectionPoolManager {</p>
<p>    // Configure MongoDB connection pool</p>
<p>    mongoOpts := options.Client().</p>
<p>        SetMaxPoolSize(uint64(config.MongoMaxPoolSize)).</p>
<p>        SetMinPoolSize(uint64(config.MongoMinPoolSize)).</p>
<p>        SetMaxConnIdleTime(config.MongoMaxIdleTime)</p>
    
<p>    mongoClient, _ := mongo.Connect(context.Background(), mongoOpts)</p>
    
<p>    // Configure Redis connection pool</p>
<p>    redisClient := redis.NewClient(&redis.Options{</p>
<p>        PoolSize:    config.RedisPoolSize,</p>
<p>        IdleTimeout: config.RedisIdleTimeout,</p>
<p>    })</p>
    
<p>    // Configure HTTP client pool</p>
<p>    httpClient := &http.Client{</p>
<p>        Transport: &http.Transport{</p>
<p>            MaxIdleConns:        config.HTTPMaxIdleConns,</p>
<p>            IdleConnTimeout:     config.HTTPIdleConnTimeout,</p>
<p>            TLSHandshakeTimeout: 10 <em> time.Second,</p>
<p>        },</p>
<p>        Timeout: 30 </em> time.Second,</p>
<p>    }</p>
    
<p>    return &ConnectionPoolManager{</p>
<p>        mongoPool: mongoClient,</p>
<p>        redisPool: redisClient,</p>
<p>        httpPool:  httpClient,</p>
<p>        config:    config,</p>
<p>    }</p>
<p>}</code></pre></p>
<h3>11.2 Batch Operations</h3>
<pre><code class="language-go">func (service <em>TaskService) BatchUpdateTaskStatus(
<p>    updates []TaskStatusUpdate,</p>
<p>) error {</p>
<p>    const batchSize = 1000</p>
    
<p>    for i := 0; i < len(updates); i += batchSize {</p>
<p>        end := i + batchSize</p>
<p>        if end > len(updates) {</p>
<p>            end = len(updates)</p>
<p>        }</p>
        
<p>        batch := updates[i:end]</p>
<p>        if err := service.processBatch(batch); err != nil {</p>
<p>            return err</p>
<p>        }</p>
<p>    }</p>
    
<p>    return nil</p>
<p>}</p>
<p>func (service </em>TaskService) processBatch(batch []TaskStatusUpdate) error {</p>
<p>    // Build bulk write operations</p>
<p>    var operations []mongo.WriteModel</p>
    
<p>    for _, update := range batch {</p>
<p>        filter := bson.M{"task_request_id": update.TaskRequestID}</p>
<p>        updateDoc := bson.M{</p>
<p>            "$set": bson.M{</p>
<p>                "status":         update.Status,</p>
<p>                "response":       update.Response,</p>
<p>                "updated_date":   time.Now().UnixMilli(),</p>
<p>            },</p>
<p>        }</p>
        
<p>        operation := mongo.NewUpdateOneModel().</p>
<p>            SetFilter(filter).</p>
<p>            SetUpdate(updateDoc)</p>
        
<p>        operations = append(operations, operation)</p>
<p>    }</p>
    
<p>    // Execute bulk write</p>
<p>    opts := options.BulkWrite().SetOrdered(false)</p>
<p>    _, err := service.collection.BulkWrite(</p>
<p>        context.Background(),</p>
<p>        operations,</p>
<p>        opts,</p>
<p>    )</p>
    
<p>    return err</p>
<p>}</code></pre></p>
<h3>11.3 Memory Management</h3>
<pre><code class="language-go">type ObjectPool struct {
<p>    pool sync.Pool</p>
<p>}</p>
<p>func NewObjectPool(factory func() interface{}) <em>ObjectPool {</p>
<p>    return &ObjectPool{</p>
<p>        pool: sync.Pool{</p>
<p>            New: factory,</p>
<p>        },</p>
<p>    }</p>
<p>}</p>
<p>func (op </em>ObjectPool) Get() interface{} {</p>
<p>    return op.pool.Get()</p>
<p>}</p>
<p>func (op <em>ObjectPool) Put(obj interface{}) {</p>
<p>    op.pool.Put(obj)</p>
<p>}</p>
<p>// Example usage for task requests</p>
<p>var taskRequestPool = NewObjectPool(func() interface{} {</p>
<p>    return &models.TaskRequest{}</p>
<p>})</p>
<p>func ProcessTaskRequest(data []byte) error {</p>
<p>    // Get object from pool</p>
<p>    req := taskRequestPool.Get().(</em>models.TaskRequest)</p>
<p>    defer taskRequestPool.Put(req)</p>
    
<p>    // Reset object state</p>
<p>    <em>req = models.TaskRequest{}</p>
    
<p>    // Process request</p>
<p>    if err := json.Unmarshal(data, req); err != nil {</p>
<p>        return err</p>
<p>    }</p>
    
<p>    // ... process request</p>
    
<p>    return nil</p>
<p>}</code></pre></p>
<p>---</p>
<h2>12. Testing Strategy</h2>
<h3>12.1 Unit Testing Structure</h3>
<pre><code class="language-go">// Test file: controllers/playbookcontroller_test.go
<p>package controllers</p>
<p>import (</p>
<p>    "testing"</p>
<p>    "github.com/stretchr/testify/assert"</p>
<p>    "github.com/stretchr/testify/mock"</p>
<p>)</p>
<p>type MockMongoSession struct {</p>
<p>    mock.Mock</p>
<p>}</p>
<p>func (m </em>MockMongoSession) FindSingleDocument(filter, opts, result interface{}) error {</p>
<p>    args := m.Called(filter, opts, result)</p>
<p>    return args.Error(0)</p>
<p>}</p>
<p>func TestPlaybookController_RunSelectedPlaybook(t <em>testing.T) {</p>
<p>    // Arrange</p>
<p>    mockSession := new(MockMongoSession)</p>
<p>    controller := NewPlaybookController()</p>
    
<p>    expectedPlaybook := models.PlaybookObject{</p>
<p>        ID:   1001,</p>
<p>        Name: "Test Playbook",</p>
<p>        Definition: <code>[{"task_seq": 1, "type": "start"}]</code>,</p>
<p>    }</p>
    
<p>    mockSession.On("FindSingleDocument", </p>
<p>        mock.Anything, mock.Anything, mock.Anything).</p>
<p>        Return(nil).</p>
<p>        Run(func(args mock.Arguments) {</p>
<p>            result := args.Get(2).(</em>models.PlaybookObject)</p>
<p>            <em>result = expectedPlaybook</p>
<p>        })</p>
    
<p>    // Act</p>
<p>    result, err := controller.RunSelectedPlaybook(</p>
<p>        "test_tenant",</p>
<p>        "Test Playbook",</p>
<p>        "12345",</p>
<p>        mockSession,</p>
<p>    )</p>
    
<p>    // Assert</p>
<p>    assert.NoError(t, err)</p>
<p>    assert.NotEmpty(t, result.PlaybookExecutionID)</p>
<p>    mockSession.AssertExpectations(t)</p>
<p>}</p>
<p>func TestPlaybookExecutionController_ParallelExecution(t </em>testing.T) {</p>
<p>    // Test parallel task execution</p>
<p>    controller := &PlaybookExecutionController{</p>
<p>        PlayBookTasksMap: make(map[int]executionModels.PlayBookTask),</p>
<p>    }</p>
    
<p>    // Create test tasks</p>
<p>    tasks := []executionModels.PlayBookTask{</p>
<p>        {TaskSeq: 1, TaskName: "Task 1", Type: "integration"},</p>
<p>        {TaskSeq: 2, TaskName: "Task 2", Type: "integration"},</p>
<p>        {TaskSeq: 3, TaskName: "Task 3", Type: "integration"},</p>
<p>    }</p>
    
<p>    // Execute parallel tasks</p>
<p>    err := controller.executeParallelTasks(tasks, mockSession)</p>
    
<p>    assert.NoError(t, err)</p>
<p>    assert.Equal(t, 3, len(controller.PlayBookTasksMap))</p>
<p>}</code></pre></p>
<h3>12.2 Integration Testing</h3>
<pre><code class="language-go">// Test file: integration/playbook_execution_test.go
<p>package integration</p>
<p>import (</p>
<p>    "testing"</p>
<p>    "context"</p>
<p>    "time"</p>
<p>)</p>
<p>func TestPlaybookExecutionEndToEnd(t <em>testing.T) {</p>
<p>    // Setup test environment</p>
<p>    testDB := setupTestDatabase(t)</p>
<p>    defer cleanupTestDatabase(testDB)</p>
    
<p>    testRedis := setupTestRedis(t)</p>
<p>    defer cleanupTestRedis(testRedis)</p>
    
<p>    // Create test playbook</p>
<p>    playbook := createTestPlaybook(t, testDB)</p>
    
<p>    // Create test case</p>
<p>    testCase := createTestCase(t, testDB)</p>
    
<p>    // Execute playbook</p>
<p>    executionID, err := executePlaybook(</p>
<p>        playbook.Name,</p>
<p>        testCase.ID,</p>
<p>        testDB,</p>
<p>        testRedis,</p>
<p>    )</p>
    
<p>    assert.NoError(t, err)</p>
<p>    assert.NotEmpty(t, executionID)</p>
    
<p>    // Wait for completion</p>
<p>    timeout := time.After(30 </em> time.Second)</p>
<p>    ticker := time.Tick(1 <em> time.Second)</p>
    
<p>    for {</p>
<p>        select {</p>
<p>        case <-timeout:</p>
<p>            t.Fatal("Playbook execution timeout")</p>
<p>        case <-ticker:</p>
<p>            status := getExecutionStatus(executionID, testDB)</p>
<p>            if status == "completed" {</p>
<p>                return</p>
<p>            }</p>
<p>            if status == "failed" {</p>
<p>                t.Fatal("Playbook execution failed")</p>
<p>            }</p>
<p>        }</p>
<p>    }</p>
<p>}</code></pre></p>
<h3>12.3 Performance Testing</h3>
<pre><code class="language-go">// Test file: performance/load_test.go
<p>package performance</p>
<p>import (</p>
<p>    "testing"</p>
<p>    "sync"</p>
<p>    "time"</p>
<p>)</p>
<p>func BenchmarkParallelPlaybookExecution(b </em>testing.B) {</p>
<p>    controller := setupPlaybookController()</p>
    
<p>    b.ResetTimer()</p>
<p>    b.RunParallel(func(pb <em>testing.PB) {</p>
<p>        for pb.Next() {</p>
<p>            _, err := controller.RunSelectedPlaybook(</p>
<p>                "test_tenant",</p>
<p>                "Load Test Playbook",</p>
<p>                generateRandomCaseID(),</p>
<p>                mockSession,</p>
<p>            )</p>
<p>            if err != nil {</p>
<p>                b.Error(err)</p>
<p>            }</p>
<p>        }</p>
<p>    })</p>
<p>}</p>
<p>func TestConcurrentPlaybookExecution(t </em>testing.T) {</p>
<p>    const numGoroutines = 100</p>
<p>    const numExecutions = 10</p>
    
<p>    var wg sync.WaitGroup</p>
<p>    controller := setupPlaybookController()</p>
    
<p>    for i := 0; i < numGoroutines; i++ {</p>
<p>        wg.Add(1)</p>
<p>        go func(routineID int) {</p>
<p>            defer wg.Done()</p>
            
<p>            for j := 0; j < numExecutions; j++ {</p>
<p>                _, err := controller.RunSelectedPlaybook(</p>
<p>                    fmt.Sprintf("tenant_%d", routineID),</p>
<p>                    "Concurrent Test Playbook",</p>
<p>                    fmt.Sprintf("case_%d_%d", routineID, j),</p>
<p>                    mockSession,</p>
<p>                )</p>
                
<p>                if err != nil {</p>
<p>                    t.Errorf("Execution failed: %v", err)</p>
<p>                }</p>
<p>            }</p>
<p>        }(i)</p>
<p>    }</p>
    
<p>    wg.Wait()</p>
<p>}</code></pre></p>
<p>---</p>
<h2>Conclusion</h2>
<p>This Low Level Design document provides comprehensive implementation details for the Securaa Playbook Service, including:</p>
<ul>
<li><strong>Detailed component specifications</strong> with class diagrams and method signatures</li>
<li><strong>Complete database schema</strong> with indexing strategies</li>
<li><strong>API specifications</strong> with validation rules and error handling</li>
<li><strong>Algorithm implementations</strong> for critical operations</li>
<li><strong>Concurrency patterns</strong> and thread safety mechanisms</li>
<li><strong>Performance optimizations</strong> and resource management</li>
<li><strong>Testing strategies</strong> for quality assurance</li>
</ul>
<p>This document serves as the technical blueprint for implementing, maintaining, and extending the Securaa Playbook Service at the code level.</p>

    </main>
    
    <footer class="main-footer">
        <p>&copy; 2025 Securaa Platform. All rights reserved.</p>
    </footer>
    
    <script src="lib/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#1976d2',
                primaryTextColor: '#000000',
                primaryBorderColor: '#0d47a1',
                lineColor: '#1976d2',
                secondaryColor: '#f5f5f5',
                tertiaryColor: '#ffffff'
            }
        });
    </script>
    <script src="assets/js/documentation.js"></script>
</body>
</html>