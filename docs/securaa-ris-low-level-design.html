<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Securaa Platform Documentation - Securaa RIS - Low Level Design">
    <title>Securaa RIS - Low Level Design - Securaa Documentation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>

:root {
    --primary-color: #4f46e5;
    --primary-dark: #3730a3;
    --primary-light: #818cf8;
    --secondary-color: #06b6d4;
    --accent-color: #f59e0b;
    --success-color: #10b981;
    --warning-color: #f59e0b;
    --error-color: #ef4444;
    --text-primary: #1f2937;
    --text-secondary: #6b7280;
    --text-muted: #9ca3af;
    --bg-primary: #ffffff;
    --bg-secondary: #f9fafb;
    --bg-tertiary: #f3f4f6;
    --border-color: #e5e7eb;
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    scroll-behavior: smooth;
    font-size: 16px;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    line-height: 1.7;
    color: var(--text-primary);
    background-color: var(--bg-secondary);
}

/* Header */
.main-header {
    background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-dark) 100%);
    color: white;
    padding: 1rem 2rem;
    position: sticky;
    top: 0;
    z-index: 1000;
    box-shadow: var(--shadow-lg);
}

.header-content {
    max-width: 1400px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.header-logo {
    font-size: 1.5rem;
    font-weight: 700;
    letter-spacing: -0.025em;
}

.header-logo span {
    color: var(--secondary-color);
}

/* Navigation */
.documentation-nav {
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border-color);
    padding: 0.75rem 2rem;
    position: sticky;
    top: 60px;
    z-index: 999;
    box-shadow: var(--shadow-sm);
}

.nav-links {
    max-width: 1400px;
    margin: 0 auto;
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    justify-content: center;
}

.nav-links a {
    color: var(--text-secondary);
    text-decoration: none;
    font-size: 0.875rem;
    font-weight: 500;
    padding: 0.5rem 0.75rem;
    border-radius: 0.375rem;
    transition: all 0.2s ease;
}

.nav-links a:hover {
    color: var(--primary-color);
    background: var(--bg-tertiary);
}

/* Main Content */
.main-content {
    max-width: 1000px;
    margin: 2rem auto;
    padding: 2.5rem;
    background: var(--bg-primary);
    border-radius: 1rem;
    box-shadow: var(--shadow-md);
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
    color: var(--text-primary);
    font-weight: 700;
    line-height: 1.3;
    margin-top: 2rem;
    margin-bottom: 1rem;
}

h1 {
    font-size: 2.5rem;
    background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    padding-bottom: 0.75rem;
    border-bottom: 3px solid var(--primary-color);
    margin-top: 0;
}

h2 {
    font-size: 1.875rem;
    color: var(--primary-dark);
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 0.5rem;
}

h3 {
    font-size: 1.5rem;
    color: var(--text-primary);
}

h4 {
    font-size: 1.25rem;
    color: var(--text-secondary);
}

h5 {
    font-size: 1.125rem;
}

h6 {
    font-size: 1rem;
    color: var(--text-muted);
}

p {
    margin-bottom: 1rem;
    color: var(--text-primary);
}

/* Links */
a {
    color: var(--primary-color);
    text-decoration: none;
    transition: color 0.2s ease;
}

a:hover {
    color: var(--primary-dark);
    text-decoration: underline;
}

/* Lists */
ul, ol {
    margin-bottom: 1rem;
    padding-left: 1.5rem;
}

li {
    margin-bottom: 0.5rem;
}

li > ul, li > ol {
    margin-top: 0.5rem;
    margin-bottom: 0;
}

/* Code Blocks */
pre {
    background: #1e1e1e;
    color: #d4d4d4;
    padding: 1.25rem;
    border-radius: 0.5rem;
    overflow-x: auto;
    margin: 1.5rem 0;
    font-size: 0.875rem;
    line-height: 1.6;
    box-shadow: var(--shadow-md);
}

code {
    font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
    font-size: 0.875em;
}

:not(pre) > code {
    background: var(--bg-tertiary);
    color: var(--primary-dark);
    padding: 0.2rem 0.4rem;
    border-radius: 0.25rem;
    font-size: 0.875em;
}

/* Tables */
table {
    width: 100%;
    border-collapse: collapse;
    margin: 1.5rem 0;
    font-size: 0.9rem;
    box-shadow: var(--shadow-sm);
    border-radius: 0.5rem;
    overflow: hidden;
}

thead {
    background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
    color: white;
}

th {
    padding: 1rem;
    text-align: left;
    font-weight: 600;
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.05em;
}

td {
    padding: 0.875rem 1rem;
    border-bottom: 1px solid var(--border-color);
}

tr:nth-child(even) {
    background: var(--bg-secondary);
}

tr:hover {
    background: var(--bg-tertiary);
}

/* Blockquotes */
blockquote {
    border-left: 4px solid var(--primary-color);
    padding: 1rem 1.5rem;
    margin: 1.5rem 0;
    background: var(--bg-secondary);
    border-radius: 0 0.5rem 0.5rem 0;
    font-style: italic;
    color: var(--text-secondary);
}

blockquote p:last-child {
    margin-bottom: 0;
}

/* Mermaid Diagrams - Enhanced Styling */
.mermaid {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 2rem 0;
    padding: 1.5rem;
    background: linear-gradient(135deg, #fafbfc 0%, #f0f4f8 100%);
    border-radius: 0.75rem;
    border: 1px solid var(--border-color);
    box-shadow: var(--shadow-sm);
    overflow-x: auto;
    overflow-y: visible;
    min-height: 200px;
}

.mermaid svg {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 0 auto;
}

/* Ensure diagrams scale properly */
.mermaid[data-processed="true"] {
    min-height: auto;
}

/* Diagram container for better control */
.diagram-container {
    width: 100%;
    overflow-x: auto;
    padding: 1rem 0;
}

/* HR Styling */
hr {
    border: none;
    border-top: 2px solid var(--border-color);
    margin: 2.5rem 0;
}

/* Table of Contents */
.toc {
    background: var(--bg-secondary);
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 2rem;
    border: 1px solid var(--border-color);
}

.toc-title {
    font-weight: 700;
    color: var(--primary-color);
    margin-bottom: 1rem;
    font-size: 1.125rem;
}

.toc ul {
    list-style: none;
    padding-left: 0;
}

.toc li {
    margin-bottom: 0.5rem;
}

.toc a {
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.toc a:hover {
    color: var(--primary-color);
}

/* Document Info Box */
.doc-info {
    background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
    border: 1px solid var(--border-color);
    border-radius: 0.5rem;
    padding: 1rem 1.5rem;
    margin-bottom: 2rem;
    font-size: 0.875rem;
}

.doc-info strong {
    color: var(--primary-color);
}

/* Footer */
.footer {
    text-align: center;
    padding: 2rem;
    background: var(--bg-tertiary);
    color: var(--text-muted);
    font-size: 0.875rem;
    margin-top: 2rem;
}

/* Scrollbar Styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: var(--bg-tertiary);
}

::-webkit-scrollbar-thumb {
    background: var(--text-muted);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--text-secondary);
}

/* Print Styles */
@media print {
    .main-header, .documentation-nav, .footer {
        display: none !important;
    }

    .main-content {
        max-width: none;
        margin: 0;
        padding: 20px;
        box-shadow: none;
        border-radius: 0;
    }

    body {
        background: white;
        font-size: 11pt;
    }

    h1 {
        font-size: 24pt;
        -webkit-text-fill-color: var(--primary-dark);
        page-break-after: avoid;
    }

    h2, h3, h4 {
        page-break-after: avoid;
    }

    pre {
        background: #f5f5f5 !important;
        color: #333 !important;
        border: 1px solid #ddd;
        page-break-inside: avoid;
        font-size: 9pt;
    }

    table {
        page-break-inside: avoid;
    }

    .mermaid {
        page-break-inside: avoid;
        background: white !important;
        border: 1px solid #ddd;
        max-width: 100% !important;
    }

    .mermaid svg {
        max-width: 100% !important;
        max-height: 700px !important;
    }

    a {
        color: var(--primary-dark) !important;
        text-decoration: none !important;
    }
}

/* Responsive Design */
@media (max-width: 768px) {
    .main-content {
        margin: 1rem;
        padding: 1.5rem;
        border-radius: 0.5rem;
    }

    h1 {
        font-size: 1.75rem;
    }

    h2 {
        font-size: 1.5rem;
    }

    .nav-links {
        gap: 0.75rem;
    }

    .nav-links a {
        font-size: 0.75rem;
        padding: 0.375rem 0.5rem;
    }

    pre {
        font-size: 0.8rem;
        padding: 1rem;
    }

    table {
        font-size: 0.8rem;
    }

    th, td {
        padding: 0.5rem;
    }
}

/* Animation for smooth transitions */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.main-content {
    animation: fadeIn 0.3s ease-out;
}

/* Index-specific styles */
.hero {
    text-align: center;
    padding: 3rem 0;
    background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
    border-radius: 1rem;
    margin-bottom: 3rem;
}

.hero h1 {
    font-size: 3rem;
    margin-bottom: 1rem;
    border: none;
    padding: 0;
}

.hero p {
    font-size: 1.25rem;
    color: var(--text-secondary);
    max-width: 600px;
    margin: 0 auto;
}

.doc-sections {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
    margin-top: 2rem;
}

.doc-card {
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 0.75rem;
    padding: 1.5rem;
    transition: all 0.3s ease;
    box-shadow: var(--shadow-sm);
}

.doc-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-lg);
    border-color: var(--primary-light);
}

.doc-card h3 {
    color: var(--primary-color);
    font-size: 1.25rem;
    margin-top: 0;
    margin-bottom: 0.75rem;
}

.doc-card p {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin-bottom: 1rem;
}

.doc-card .links {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
}

.doc-card .links a {
    font-size: 0.875rem;
    padding: 0.5rem 1rem;
    background: var(--bg-secondary);
    border-radius: 0.375rem;
    transition: all 0.2s ease;
}

.doc-card .links a:hover {
    background: var(--primary-color);
    color: white;
    text-decoration: none;
}

.section-title {
    font-size: 1.75rem;
    color: var(--primary-dark);
    margin-top: 3rem;
    margin-bottom: 1.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--border-color);
}

    </style>
</head>
<body>
    <header class="main-header">
        <div class="header-content">
            <div class="header-logo">Securaa<span>Docs</span></div>
            <div class="header-meta">
                <span>Generated: December 04, 2025</span>
            </div>
        </div>
    </header>

    <nav class="documentation-nav">
        <div class="nav-links">
            <a href="index.html">Home</a>
            <a href="securaa-platform-high-level-design.html">Platform</a>
            <a href="securaa-playbook-high-level-design.html">Playbook</a>
            <a href="securaa-siem-high-level-design.html">SIEM</a>
            <a href="securaa-user-high-level-design.html">User Service</a>
            <a href="securaa-custom-services-high-level-design.html">Custom Services</a>
            <a href="sia-service-high-level-design.html">SIA Service</a>
            <a href="securaa-ris-high-level-design.html">RIS</a>
        </div>
    </nav>

    <main class="main-content">
        <h1 id="remote-integrated-services-ris-system-low-level-design-lld">Remote Integrated Services (RIS) System - Low-Level Design (LLD)<a class="headerlink" href="#remote-integrated-services-ris-system-low-level-design-lld" title="Permanent link">&para;</a></h1>
<h2 id="table-of-contents">Table of Contents<a class="headerlink" href="#table-of-contents" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#detailed-component-design">Detailed Component Design</a></li>
<li><a href="#class-diagrams-and-implementation">Class Diagrams and Implementation</a></li>
<li><a href="#database-design-and-schema">Database Design and Schema</a></li>
<li><a href="#api-specifications-and-protocols">API Specifications and Protocols</a></li>
<li><a href="#websocket-protocol-implementation">WebSocket Protocol Implementation</a></li>
<li><a href="#task-execution-framework">Task Execution Framework</a></li>
<li><a href="#sequence-diagrams-and-interaction-flows">Sequence Diagrams and Interaction Flows</a></li>
<li><a href="#error-handling-and-logging-framework">Error Handling and Logging Framework</a></li>
<li><a href="#configuration-management-system">Configuration Management System</a></li>
<li><a href="#security-implementation-details">Security Implementation Details</a></li>
<li><a href="#performance-optimization-techniques">Performance Optimization Techniques</a></li>
<li><a href="#testing-and-quality-assurance">Testing and Quality Assurance</a></li>
<li><a href="#deployment-and-devops">Deployment and DevOps</a></li>
</ol>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>This Low-Level Design document provides comprehensive technical specifications for the Remote Integrated Services (RIS) System implementation. It includes detailed class structures, method signatures, database schemas, API endpoints, protocol specifications, and implementation specifics for both server and client components.</p>
<h3 id="document-scope">Document Scope<a class="headerlink" href="#document-scope" title="Permanent link">&para;</a></h3>
<p>This LLD covers:<br />
- <strong>Implementation Details</strong>: Specific code structures, methods, and algorithms<br />
- <strong>Technical Specifications</strong>: Database schemas, API endpoints, protocol definitions<br />
- <strong>Integration Patterns</strong>: How components interact and communicate<br />
- <strong>Quality Attributes</strong>: Performance, security, reliability, and maintainability considerations<br />
- <strong>Operational Aspects</strong>: Deployment, monitoring, and maintenance procedures</p>
<h3 id="design-principles">Design Principles<a class="headerlink" href="#design-principles" title="Permanent link">&para;</a></h3>
<p>The implementation follows these core principles:<br />
- <strong>Simplicity</strong>: Clear, readable, and maintainable code<br />
- <strong>Performance</strong>: Optimized for high throughput and low latency<br />
- <strong>Security</strong>: Security-by-design with comprehensive protection mechanisms<br />
- <strong>Scalability</strong>: Horizontal and vertical scaling capabilities<br />
- <strong>Reliability</strong>: Fault tolerance and automatic recovery mechanisms</p>
<h2 id="detailed-component-design">Detailed Component Design<a class="headerlink" href="#detailed-component-design" title="Permanent link">&para;</a></h2>
<h3 id="1-ris-server-component-design">1. RIS Server Component Design<a class="headerlink" href="#1-ris-server-component-design" title="Permanent link">&para;</a></h3>
<h4 id="11-main-application-structure">1.1 Main Application Structure<a class="headerlink" href="#11-main-application-structure" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">// App represents the main application structure
type App struct {
    Router                 *mux.Router                    // HTTP router for REST endpoints
    AccessTokenHashMap     map[string]int64               // JWT token expiry tracking
    Socket                 *websocket.Conn                // WebSocket connection handler
    SocketClients          []*websocket.Conn              // Multiple WebSocket connections
    DBSession              map[string]common.SessionStruct // Database sessions per tenant
    ConfigObject           config.ConfigStruct            // Application configuration
    SecondaryMongoDBHosts  []string                       // Secondary DB hosts for HA
    BuildType              string                         // Deployment type (mssp/standalone)
    DisconnectedRISClients map[string]int                 // Disconnected client tracking
    RISClientsResponse     map[string]int                 // Client response tracking
    MapMutex               sync.RWMutex                   // Thread-safe map access
    RequestResponseLog     bool                           // Logging configuration
}

// Core application methods
func (a *App) Initialize()
func (a *App) Run(port string, certFile string, keyFile string)
func (a *App) initializeRoutes()
func (a *App) loggingMiddleware(next http.Handler) http.Handler
func (a *App) liveWebSockets(socketConnection *websocket.Conn, 
                           dbSession map[string]common.SessionStruct, 
                           configObject config.ConfigStruct)
</code></pre>

<h4 id="12-ris-controller-design">1.2 RIS Controller Design<a class="headerlink" href="#12-ris-controller-design" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type RISController struct{}

// Core RIS management methods
func (rc RISController) GetAllRIS(w http.ResponseWriter, r *http.Request,
                                dbSession map[string]common.SessionStruct,
                                configObject config.ConfigStruct)

func (rc RISController) AddNewRIS(w http.ResponseWriter, r *http.Request,
                                dbSession map[string]common.SessionStruct,
                                configObject config.ConfigStruct)

func (rc RISController) UpdateRIS(w http.ResponseWriter, r *http.Request,
                                dbSession map[string]common.SessionStruct,
                                configObject config.ConfigStruct)

func (rc RISController) DeleteRIS(w http.ResponseWriter, r *http.Request,
                                dbSession map[string]common.SessionStruct,
                                configObject config.ConfigStruct)

// Client management methods
func (rc RISController) GetSingleRISClient(w http.ResponseWriter, r *http.Request,
                                         dbSession map[string]common.SessionStruct,
                                         configObject config.ConfigStruct)

func (rc RISController) GetRISClientConfigData(w http.ResponseWriter, r *http.Request,
                                             dbSession map[string]common.SessionStruct,
                                             configObject config.ConfigStruct,
                                             secondaryMongoDBHosts []string)

// Status management methods
func (rc RISController) SetClientStatus(dbSession map[string]common.SessionStruct,
                                      configObject config.ConfigStruct) error

func (rc RISController) SetTenantStatus(dbSession map[string]common.SessionStruct,
                                      configObject config.ConfigStruct) error
</code></pre>

<h4 id="13-ris-model-design">1.3 RIS Model Design<a class="headerlink" href="#13-ris-model-design" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type RIS struct {
    ID               int    `json:&quot;id&quot; bson:&quot;id&quot;`
    Name             string `json:&quot;name&quot; bson:&quot;name&quot;`
    Description      string `json:&quot;description&quot; bson:&quot;description&quot;`
    Host             string `json:&quot;host&quot; bson:&quot;host&quot;`
    Status           string `json:&quot;status&quot; bson:&quot;status&quot;`
    ConnectionStatus string `json:&quot;connection_status&quot; bson:&quot;connection_status&quot;`
    CreatedDate      int64  `json:&quot;createddate&quot; bson:&quot;createddate&quot;`
    UpdatedDate      int64  `json:&quot;updateddate&quot; bson:&quot;updateddate&quot;`
    Version          string `json:&quot;version&quot; bson:&quot;version&quot;`
    UniqueClientID   string `json:&quot;unique_client_id&quot; bson:&quot;unique_client_id&quot;`
    TenantCode       string `json:&quot;tenantcode&quot; bson:&quot;tenantcode&quot;`
}

// Model methods
func (ris *RIS) GetRISList(mongoDBClient mongo_driver.MongoClientWrapper,
                         configObject config.ConfigStruct) ([]map[string]string, error)

func (ris *RIS) GetRISData(mongoDBClient mongo_driver.MongoClientWrapper,
                         risID int, configObject config.ConfigStruct) (RIS, error)

func (ris *RIS) AddRIS(mongoDBClient mongo_driver.MongoClientWrapper,
                     configObject config.ConfigStruct) error

func (ris *RIS) UpdateRIS(mongoDBClient mongo_driver.MongoClientWrapper,
                        configObject config.ConfigStruct) error

func (ris *RIS) DeleteRIS(mongoDBClient mongo_driver.MongoClientWrapper,
                        configObject config.ConfigStruct) error
</code></pre>

<h3 id="2-ris-client-component-design">2. RIS Client Component Design<a class="headerlink" href="#2-ris-client-component-design" title="Permanent link">&para;</a></h3>
<h4 id="21-main-application-structure">2.1 Main Application Structure<a class="headerlink" href="#21-main-application-structure" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type App struct {
    Router       *mux.Router            // HTTP router for client endpoints
    ConfigObject config.ConfigStruct    // Configuration object
    CLI          *client.Client         // Docker client for service management
}

// Core application methods
func (a *App) Initialize()
func (a *App) Run(port string)
func (a *App) initializeRoutes()
func (a *App) loggingMiddleware(next http.Handler) http.Handler
func (a *App) risClient() // WebSocket client connection management
</code></pre>

<h4 id="22-task-handler-controller-design">2.2 Task Handler Controller Design<a class="headerlink" href="#22-task-handler-controller-design" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type TaskHandlerController struct{}

// Task execution methods
func (tc TaskHandlerController) RunTaskByHandler(w http.ResponseWriter, r *http.Request)
func (tc TaskHandlerController) RunTask(w http.ResponseWriter, r *http.Request)
func (tc TaskHandlerController) ADTestConnectivity(w http.ResponseWriter, r *http.Request)

// Utility methods
func IsJson(str string) bool
</code></pre>

<h4 id="23-ris-client-controller-design">2.3 RIS Client Controller Design<a class="headerlink" href="#23-ris-client-controller-design" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type RISClientController struct{}

// Service management methods
func (rc RISClientController) DeployServices(configObject config.ConfigStruct) error
func (rc RISClientController) CheckClientStatus(configObject config.ConfigStruct) (string, error)
func (rc RISClientController) IsServiceRunning(cli *client.Client, serviceName string) (bool, error)

// Network management methods
func (rc RISClientController) GetExternalIP() string
func (rc RISClientController) GetInternalIP() (string, error)

// File management methods
func readHostFile() string
func updateHostConfig(host string) error
</code></pre>

<h4 id="24-task-models-design">2.4 Task Models Design<a class="headerlink" href="#24-task-models-design" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type TaskHandlerRequest struct {
    Method      string `json:&quot;method&quot; bson:&quot;method&quot;`
    REST        string `json:&quot;rest&quot; bson:&quot;rest&quot;`
    Port        string `json:&quot;port&quot; bson:&quot;port&quot;`
    BaseURL     string `json:&quot;baseurl&quot; bson:&quot;baseurl&quot;`
    Params      string `json:&quot;params&quot; bson:&quot;params&quot;`
    Data        []byte `json:&quot;data&quot; bson:&quot;data&quot;`
    AccessToken string `json:&quot;access_token&quot; bson:&quot;access_token&quot;`
    JwtToken    string `json:&quot;jwt_token&quot; bson:&quot;jwt_token&quot;`
}

type TaskRequest struct {
    Method         string               `json:&quot;method&quot; bson:&quot;method&quot;`
    RestURL        string               `json:&quot;resturl&quot; bson:&quot;resturl&quot;`
    RequestHeaders string               `json:&quot;headers&quot; bson:&quot;headers&quot;`
    Data           []byte               `json:&quot;data&quot; bson:&quot;data&quot;`
    AuthType       string               `json:&quot;authtype&quot; bson:&quot;authtype&quot;`
    Username       string               `json:&quot;username&quot; bson:&quot;username&quot;`
    Password       string               `json:&quot;password&quot; bson:&quot;password&quot;`
    BearerToken    string               `json:&quot;bearertoken&quot; bson:&quot;bearertoken&quot;`
    Cookies        map[int]*http.Cookie `json:&quot;cookies&quot; bson:&quot;cookies&quot;`
}

// Task execution methods
func (taskRequest *TaskHandlerRequest) BuildAndExecuteTask() ([]byte, error)
func (taskRequest *TaskRequest) ExecuteTask() ([]byte, error, int, string, 
                                             map[int]*http.Cookie, http.Header)
</code></pre>

<h2 id="class-diagrams">Class Diagrams<a class="headerlink" href="#class-diagrams" title="Permanent link">&para;</a></h2>
<h3 id="1-server-side-class-hierarchy">1. Server-Side Class Hierarchy<a class="headerlink" href="#1-server-side-class-hierarchy" title="Permanent link">&para;</a></h3>
<div class="mermaid">
classDiagram
    class App {
        +Router mux.Router
        +DBSession map~string~SessionStruct
        +ConfigObject config.ConfigStruct
        +Initialize()
        +Run()
        +initializeRoutes()
    }

    class RISController {
        +GetAllRIS()
        +AddNewRIS()
        +UpdateRIS()
        +DeleteRIS()
        +GetSingleRISClient()
    }

    class RemoteTenantController {
        +GetTenantClient()
        +GetTenantConfig()
    }

    class CacheController {
        +GetCache()
        +SetCache()
        +ClearCache()
    }

    class RISModel {
        +int ID
        +string Name
        +string Description
        +string Host
        +string Status
        +string ConnectionStatus
        +GetRISList()
        +AddRIS()
        +UpdateRIS()
    }

    class TenantDBInfo {
        +string DBName
        +string DBUsername
        +string DBPassword
        +string DBHost
    }

    class Response {
        +bool Success
        +interface Data
        +string Error
        +string DisplayMessage
    }

    App --> RISController
    App --> RemoteTenantController
    App --> CacheController
    RISController --> RISModel
    RISController --> Response
    RemoteTenantController --> TenantDBInfo
    RemoteTenantController --> Response
</div>

<h3 id="2-client-side-class-hierarchy">2. Client-Side Class Hierarchy<a class="headerlink" href="#2-client-side-class-hierarchy" title="Permanent link">&para;</a></h3>
<div class="mermaid">
classDiagram
    class App {
        +Router mux.Router
        +ConfigObject config.ConfigStruct
        +CLI client.Client
        +Initialize()
        +Run()
        +initializeRoutes()
        +risClient()
    }

    class TaskHandlerController {
        +RunTaskByHandler()
        +RunTask()
        +ADTestConnectivity()
    }

    class RISClientController {
        +CheckClientStatus()
        +GetInternalIP()
        +GetExternalIP()
        +DeployServices()
    }

    class RemoteConnectionController {
        +TestConnection()
        +ValidateCredentials()
    }

    class ServiceController {
        +ManageService()
        +CheckServiceStatus()
    }

    class TaskHandlerRequest {
        +string Method
        +string REST
        +string Port
        +string BaseURL
        +BuildAndExecuteTask()
    }

    class TaskRequest {
        +string Method
        +string RestURL
        +string RequestHeaders
        +byte[] Data
        +ExecuteTask()
    }

    class ClientInfo {
        +string ClientHost
        +string UniqueClientID
        +string ConnectionStatus
    }

    class ClientStatus {
        +string Status
        +string Version
        +int64 Timestamp
    }

    class Response {
        +bool Success
        +interface Data
        +string Error
        +string DisplayMessage
    }

    App --> TaskHandlerController
    App --> RISClientController
    App --> RemoteConnectionController
    App --> ServiceController
    TaskHandlerController --> TaskHandlerRequest
    TaskHandlerController --> TaskRequest
    TaskHandlerController --> Response
    RISClientController --> ClientInfo
    RISClientController --> ClientStatus
    RISClientController --> Response
</div>

<h2 id="database-design">Database Design<a class="headerlink" href="#database-design" title="Permanent link">&para;</a></h2>
<h3 id="1-mongodb-collections-schema">1. MongoDB Collections Schema<a class="headerlink" href="#1-mongodb-collections-schema" title="Permanent link">&para;</a></h3>
<h4 id="ris-collection-riscollection">RIS Collection (<code>risCollection</code>)<a class="headerlink" href="#ris-collection-riscollection" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-javascript">{
    &quot;_id&quot;: ObjectId,
    &quot;id&quot;: Number,                    // Auto-increment ID
    &quot;name&quot;: String,                  // RIS client name
    &quot;description&quot;: String,           // Description
    &quot;host&quot;: String,                  // Client host URL
    &quot;status&quot;: String,                // active/inactive/deleted
    &quot;connection_status&quot;: String,     // connected/disconnected/created
    &quot;createddate&quot;: NumberLong,       // Creation timestamp
    &quot;updateddate&quot;: NumberLong,       // Last update timestamp
    &quot;version&quot;: String,               // RIS client version
    &quot;unique_client_id&quot;: String,      // UUID for client identification
    &quot;tenantcode&quot;: String             // Associated tenant code
}
</code></pre>

<h4 id="tenants-collection-tenantscollection">Tenants Collection (<code>tenantsCollection</code>)<a class="headerlink" href="#tenants-collection-tenantscollection" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-javascript">{
    &quot;_id&quot;: ObjectId,
    &quot;id&quot;: Number,                    // Tenant ID
    &quot;db_name&quot;: String,               // Database name
    &quot;db_username&quot;: String,           // Database username
    &quot;db_password&quot;: String,           // Database password
    &quot;db_host&quot;: String,               // Database host
    &quot;tenantcode&quot;: String,            // Tenant code
    &quot;unique_client_id&quot;: String,      // UUID
    &quot;connection_status&quot;: String,     // Connection status
    &quot;status&quot;: String,                // Tenant status
    &quot;host_type&quot;: String,             // local/remote
    &quot;createddate&quot;: NumberLong,       // Creation timestamp
    &quot;updateddate&quot;: NumberLong        // Update timestamp
}
</code></pre>

<h4 id="active-instances-collection-mongoactiveinstancecollection">Active Instances Collection (<code>mongoActiveInstanceCollection</code>)<a class="headerlink" href="#active-instances-collection-mongoactiveinstancecollection" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-javascript">{
    &quot;_id&quot;: ObjectId,
    &quot;instance_id&quot;: NumberLong,       // Instance identifier
    &quot;integration_id&quot;: NumberLong,    // Integration type ID
    &quot;title&quot;: String,                 // Instance title
    &quot;status&quot;: String,                // active/inactive
    &quot;base_url&quot;: String,              // Service base URL
    &quot;uuid&quot;: String,                  // Associated RIS client UUID
    &quot;credentials_id&quot;: Number,        // Credentials reference
    &quot;customapp&quot;: Boolean,            // Custom application flag
    &quot;instance_status&quot;: String,       // Runtime status
    &quot;tenantcode&quot;: String             // Tenant association
}
</code></pre>

<h3 id="2-index-strategy">2. Index Strategy<a class="headerlink" href="#2-index-strategy" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-javascript">// RIS Collection Indexes
db.ris.createIndex({&quot;unique_client_id&quot;: 1})
db.ris.createIndex({&quot;status&quot;: 1, &quot;connection_status&quot;: 1})
db.ris.createIndex({&quot;tenantcode&quot;: 1})

// Tenants Collection Indexes
db.tenants.createIndex({&quot;unique_client_id&quot;: 1})
db.tenants.createIndex({&quot;tenantcode&quot;: 1})
db.tenants.createIndex({&quot;status&quot;: 1, &quot;connection_status&quot;: 1})

// Active Instances Collection Indexes
db.active_instances.createIndex({&quot;uuid&quot;: 1})
db.active_instances.createIndex({&quot;instance_id&quot;: 1})
db.active_instances.createIndex({&quot;tenantcode&quot;: 1, &quot;status&quot;: 1})
</code></pre>

<h2 id="api-specifications">API Specifications<a class="headerlink" href="#api-specifications" title="Permanent link">&para;</a></h2>
<h3 id="1-server-rest-api-endpoints">1. Server REST API Endpoints<a class="headerlink" href="#1-server-rest-api-endpoints" title="Permanent link">&para;</a></h3>
<h4 id="ris-management-apis">RIS Management APIs<a class="headerlink" href="#ris-management-apis" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code>GET    /platform/v1/ris                     // Get all RIS clients
POST   /platform/v1/ris                     // Add new RIS client
PUT    /platform/v1/ris                     // Update RIS client
DELETE /platform/v1/ris                     // Delete RIS client

GET    /platform/v1/risclient/{ris-id}/{host-name}  // Get RIS config data
GET    /internal/v1/risclient/{ris-uuid}             // Get single RIS client
GET    /internal/v1/dockertag                        // Get Docker tag info
</code></pre>

<h4 id="tenant-management-apis">Tenant Management APIs<a class="headerlink" href="#tenant-management-apis" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code>GET    /internal/v1/remotetenantclient/{tenant-uuid}          // Get tenant client
GET    /platform/v1/remotetenantconfigdata/{tenant-id}/{hostname}  // Get tenant config
</code></pre>

<h4 id="websocket-endpoints">WebSocket Endpoints<a class="headerlink" href="#websocket-endpoints" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code>WS     /pingpong                            // RIS client connection
WS     /pingpongdbdetails                   // Tenant DB connection
</code></pre>

<h3 id="2-client-rest-api-endpoints">2. Client REST API Endpoints<a class="headerlink" href="#2-client-rest-api-endpoints" title="Permanent link">&para;</a></h3>
<h4 id="task-execution-apis">Task Execution APIs<a class="headerlink" href="#task-execution-apis" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code>POST   /runtaskbyhandler/                   // Execute task via handler
POST   /runtask/                            // Execute third-party task
POST   /adtestconnectivity/                 // Test AD connectivity
</code></pre>

<h4 id="service-management-apis">Service Management APIs<a class="headerlink" href="#service-management-apis" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code>POST   /remoteconnection/                   // Remote connection test
POST   /manageservices/                     // Docker service management
GET    /test/                               // Health check endpoint
</code></pre>

<h3 id="3-requestresponse-specifications">3. Request/Response Specifications<a class="headerlink" href="#3-requestresponse-specifications" title="Permanent link">&para;</a></h3>
<h4 id="ris-client-registration-request">RIS Client Registration Request<a class="headerlink" href="#ris-client-registration-request" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-json">{
    &quot;clienthost&quot;: &quot;192.168.1.100&quot;,
    &quot;unique_client_id&quot;: &quot;uuid-string&quot;,
    &quot;connection_status&quot;: &quot;connected&quot;,
    &quot;isfirstping&quot;: &quot;true&quot;,
    &quot;serverhost&quot;: &quot;server.example.com&quot;,
    &quot;host_type&quot;: &quot;private&quot;,
    &quot;isnetworkchanged&quot;: &quot;false&quot;,
    &quot;tenantcode&quot;: &quot;tenant1&quot;,
    &quot;ris_nat_ip&quot;: &quot;10.0.0.100&quot;
}
</code></pre>

<h4 id="task-execution-request">Task Execution Request<a class="headerlink" href="#task-execution-request" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-json">{
    &quot;method&quot;: &quot;POST&quot;,
    &quot;resturl&quot;: &quot;https://api.example.com/endpoint&quot;,
    &quot;headers&quot;: &quot;{\&quot;Content-Type\&quot;: \&quot;application/json\&quot;}&quot;,
    &quot;data&quot;: &quot;base64-encoded-data&quot;,
    &quot;authtype&quot;: &quot;bearer&quot;,
    &quot;bearertoken&quot;: &quot;jwt-token&quot;,
    &quot;cookies&quot;: {}
}
</code></pre>

<h4 id="standard-response-format">Standard Response Format<a class="headerlink" href="#standard-response-format" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-json">{
    &quot;success&quot;: true,
    &quot;data&quot;: {},
    &quot;error&quot;: &quot;&quot;,
    &quot;displaymessage&quot;: &quot;&quot;,
    &quot;errorpath&quot;: &quot;&quot;,
    &quot;sessionexpired&quot;: false,
    &quot;cookies&quot;: {},
    &quot;headers&quot;: {}
}
</code></pre>

<h2 id="websocket-protocol-design">WebSocket Protocol Design<a class="headerlink" href="#websocket-protocol-design" title="Permanent link">&para;</a></h2>
<h3 id="1-connection-lifecycle">1. Connection Lifecycle<a class="headerlink" href="#1-connection-lifecycle" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-go">// Connection establishment
func (a *App) liveWebSockets(socketConnection *websocket.Conn,
                            dbSession map[string]common.SessionStruct,
                            configObject config.ConfigStruct) {

    clientInfo := ClientInfo{}
    messageMap := make(map[string]string)
    hostSavedMap := make(map[string]string)

    defer func() {
        socketConnection.Close()
        // Handle disconnection cleanup
    }()

    // Message processing loop
    for {
        _, bytes, err := socketConnection.ReadMessage()
        if err != nil {
            break
        }

        // Process client information
        json.Unmarshal(bytes, &amp;clientInfo)

        // Handle different message types
        switch {
        case clientInfo.IsNetworkChanged == &quot;true&quot;:
            // Handle network change
        default:
            // Regular processing
        }

        // Send response
        socketConnection.WriteMessage(websocket.TextMessage, responseBytes)
    }
}
</code></pre>

<h3 id="2-message-types-and-formats">2. Message Types and Formats<a class="headerlink" href="#2-message-types-and-formats" title="Permanent link">&para;</a></h3>
<h4 id="client-registration-message">Client Registration Message<a class="headerlink" href="#client-registration-message" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-json">{
    &quot;clienthost&quot;: &quot;client-ip&quot;,
    &quot;unique_client_id&quot;: &quot;client-uuid&quot;,
    &quot;connection_status&quot;: &quot;connected&quot;,
    &quot;isfirstping&quot;: &quot;true&quot;,
    &quot;host_type&quot;: &quot;private|public|ris_nat_ip&quot;,
    &quot;isnetworkchanged&quot;: &quot;false&quot;
}
</code></pre>

<h4 id="server-response-messages">Server Response Messages<a class="headerlink" href="#server-response-messages" title="Permanent link">&para;</a></h4>
<ul>
<li><code>"pong"</code> - Normal acknowledgment</li>
<li><code>"private ip not reachable"</code> - Network connectivity issue</li>
<li><code>"client not reachable"</code> - Client unreachable</li>
<li><code>"ris nat ip not reachable"</code> - NAT IP connectivity issue</li>
</ul>
<h3 id="3-connection-management">3. Connection Management<a class="headerlink" href="#3-connection-management" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-go">// Connection tracking
type ConnectionManager struct {
    DisconnectedRISClients map[string]int
    RISClientsResponse     map[string]int
    MapMutex               sync.RWMutex
}

func (cm *ConnectionManager) SetDisconnectedRISClientsCount(uuid string, count int) {
    cm.MapMutex.Lock()
    defer cm.MapMutex.Unlock()
    cm.DisconnectedRISClients[uuid] = count
}

func (cm *ConnectionManager) GetDisconnectedRISClientsCount(uuid string) int {
    cm.MapMutex.Lock()
    defer cm.MapMutex.Unlock()
    return cm.DisconnectedRISClients[uuid]
}
</code></pre>

<h2 id="task-execution-framework">Task Execution Framework<a class="headerlink" href="#task-execution-framework" title="Permanent link">&para;</a></h2>
<h3 id="1-task-types-and-processing">1. Task Types and Processing<a class="headerlink" href="#1-task-types-and-processing" title="Permanent link">&para;</a></h3>
<h4 id="task-handler-request-processing">Task Handler Request Processing<a class="headerlink" href="#task-handler-request-processing" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">func (tc TaskHandlerController) RunTaskByHandler(w http.ResponseWriter, r *http.Request) {
    var taskrequest models.TaskHandlerRequest
    var response models.Response

    // Decode request
    decoder := json.NewDecoder(r.Body)
    err := decoder.Decode(&amp;taskrequest)

    // Execute task
    responseData, err := taskrequest.BuildAndExecuteTask()

    // Process response
    json.Unmarshal(responseData, &amp;response)
    utils.RespondWithJSON(w, http.StatusOK, response)
}
</code></pre>

<h4 id="task-execution-implementation">Task Execution Implementation<a class="headerlink" href="#task-execution-implementation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">func (taskRequest *TaskHandlerRequest) BuildAndExecuteTask() ([]byte, error) {
    var response []byte
    var err error

    switch taskRequest.Method {
    case &quot;GET&quot;:
        restURL := taskRequest.BaseURL + &quot;:&quot; + taskRequest.Port + 
                  &quot;/&quot; + taskRequest.REST + &quot;/&quot; + taskRequest.Params
        response, err = utils.SecuraaHTTPRequest(restURL, nil, 
                       taskRequest.Method, taskRequest.AccessToken, 
                       taskRequest.JwtToken)

    case &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;PATCH&quot;:
        restURL := taskRequest.BaseURL + &quot;:&quot; + taskRequest.Port + 
                  &quot;/&quot; + taskRequest.REST + &quot;/&quot;
        response, err = utils.SecuraaHTTPRequest(restURL, taskRequest.Data, 
                       taskRequest.Method, taskRequest.AccessToken, 
                       taskRequest.JwtToken)
    }

    return response, err
}
</code></pre>

<h3 id="2-service-management">2. Service Management<a class="headerlink" href="#2-service-management" title="Permanent link">&para;</a></h3>
<h4 id="docker-service-management">Docker Service Management<a class="headerlink" href="#docker-service-management" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">func (rc RISClientController) IsServiceRunning(cli *client.Client, 
                                             serviceName string) (bool, error) {
    serviceList, err := cli.ServiceList(context.Background(), 
                                       types.ServiceListOptions{})
    if err != nil {
        return false, err
    }

    for _, service := range serviceList {
        if service.Spec.Name == serviceName {
            return true, nil
        }
    }

    return false, nil
}
</code></pre>

<h2 id="error-handling-and-logging">Error Handling and Logging<a class="headerlink" href="#error-handling-and-logging" title="Permanent link">&para;</a></h2>
<h3 id="1-error-handling-strategy">1. Error Handling Strategy<a class="headerlink" href="#1-error-handling-strategy" title="Permanent link">&para;</a></h3>
<h4 id="standardized-error-response">Standardized Error Response<a class="headerlink" href="#standardized-error-response" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">func HandleError(err error, message string) models.Response {
    response := models.Response{}
    response.Success = false
    response.Error = err.Error()
    response.DisplayMessage = message
    response.ErrorPath = getCallerInfo()
    return response
}
</code></pre>

<h4 id="error-categories">Error Categories<a class="headerlink" href="#error-categories" title="Permanent link">&para;</a></h4>
<ol>
<li><strong>Network Errors</strong>: Connection timeouts, unreachable hosts</li>
<li><strong>Authentication Errors</strong>: Invalid tokens, expired sessions</li>
<li><strong>Authorization Errors</strong>: Insufficient permissions</li>
<li><strong>Validation Errors</strong>: Invalid input data</li>
<li><strong>System Errors</strong>: Database connection issues, service unavailable</li>
</ol>
<h3 id="2-logging-implementation">2. Logging Implementation<a class="headerlink" href="#2-logging-implementation" title="Permanent link">&para;</a></h3>
<h4 id="structured-logging">Structured Logging<a class="headerlink" href="#structured-logging" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">var logger = securaalog.New(&quot;component_name&quot;)

// Log levels and usage
logger.Debug(&quot;Debug information&quot;)
logger.Info(&quot;Informational message&quot;)
logger.Error(&quot;Error message with context&quot;, err.Error())
</code></pre>

<h4 id="log-rotation-and-management">Log Rotation and Management<a class="headerlink" href="#log-rotation-and-management" title="Permanent link">&para;</a></h4>
<ul>
<li>File-based logging with automatic rotation</li>
<li>Configurable log levels per component</li>
<li>Centralized log aggregation support</li>
<li>Security-aware logging (password masking)</li>
</ul>
<h2 id="configuration-management">Configuration Management<a class="headerlink" href="#configuration-management" title="Permanent link">&para;</a></h2>
<h3 id="1-configuration-structure">1. Configuration Structure<a class="headerlink" href="#1-configuration-structure" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-go">type ConfigStruct struct {
    ServerHost         string
    MongoDBHost        string
    ElasticSearchHost  string
    LoggingPath        string
    CertFile           string
    KeyFile            string
    // ... additional configuration fields
}
</code></pre>

<h3 id="2-dynamic-configuration-updates">2. Dynamic Configuration Updates<a class="headerlink" href="#2-dynamic-configuration-updates" title="Permanent link">&para;</a></h3>
<h4 id="configuration-hot-reload">Configuration Hot-reload<a class="headerlink" href="#configuration-hot-reload" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">func (a *App) reloadConfiguration() error {
    newConfig := utils.InitConfig()
    if validateConfig(newConfig) {
        a.ConfigObject = newConfig
        return nil
    }
    return errors.New(&quot;invalid configuration&quot;)
}
</code></pre>

<h2 id="security-implementation-framework">Security Implementation Framework<a class="headerlink" href="#security-implementation-framework" title="Permanent link">&para;</a></h2>
<h3 id="1-comprehensive-tls-configuration">1. Comprehensive TLS Configuration<a class="headerlink" href="#1-comprehensive-tls-configuration" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-go">// TLS Configuration with Advanced Security Parameters
func configureTLS() *tls.Config {
    cert, err := tls.LoadX509KeyPair(&quot;ssl/certs/securaa_server.crt&quot;, &quot;ssl/private/securaa_server.key&quot;)
    if err != nil {
        log.Fatal(&quot;Failed to load TLS certificates:&quot;, err)
    }

    // Load CA certificate for client verification
    caCert, err := ioutil.ReadFile(&quot;ssl/certs/securaa-ca.pem&quot;)
    if err != nil {
        log.Fatal(&quot;Failed to load CA certificate:&quot;, err)
    }
    caCertPool := x509.NewCertPool()
    caCertPool.AppendCertsFromPEM(caCert)

    return &amp;tls.Config{
        Certificates:             []tls.Certificate{cert},
        ClientAuth:               tls.RequireAndVerifyClientCert,
        ClientCAs:                caCertPool,
        MinVersion:               tls.VersionTLS12,
        MaxVersion:               tls.VersionTLS13,
        PreferServerCipherSuites: true,
        CipherSuites: []uint16{
            tls.TLS_AES_256_GCM_SHA384,           // TLS 1.3
            tls.TLS_CHACHA20_POLY1305_SHA256,      // TLS 1.3
            tls.TLS_AES_128_GCM_SHA256,           // TLS 1.3
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,    // TLS 1.2
            tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,     // TLS 1.2
            tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,    // TLS 1.2
        },
        CurvePreferences: []tls.CurveID{
            tls.X25519,
            tls.CurveP256,
            tls.CurveP384,
        },
        SessionTicketsDisabled: false,
        InsecureSkipVerify:     false,
        ServerName:             &quot;securaa-ris-server&quot;,
    }
}

// WebSocket TLS Upgrader with Security Headers
func createSecureWebSocketUpgrader() websocket.Upgrader {
    return websocket.Upgrader{
        ReadBufferSize:    4096,
        WriteBufferSize:   4096,
        EnableCompression: true,
        CheckOrigin: func(r *http.Request) bool {
            origin := r.Header.Get(&quot;Origin&quot;)
            return isAllowedOrigin(origin)
        },
        Subprotocols: []string{&quot;securaa-ris-protocol&quot;},
        Error: func(w http.ResponseWriter, r *http.Request, status int, reason error) {
            log.Printf(&quot;WebSocket error: %v&quot;, reason)
            w.Header().Set(&quot;Sec-WebSocket-Version&quot;, &quot;13&quot;)
            http.Error(w, http.StatusText(status), status)
        },
    }
}
</code></pre>

<h3 id="2-advanced-authentication-and-authorization-framework">2. Advanced Authentication and Authorization Framework<a class="headerlink" href="#2-advanced-authentication-and-authorization-framework" title="Permanent link">&para;</a></h3>
<h4 id="multi-factor-jwt-token-validation">Multi-Factor JWT Token Validation<a class="headerlink" href="#multi-factor-jwt-token-validation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type JWTClaims struct {
    UserID      string    `json:&quot;user_id&quot;`
    TenantID    string    `json:&quot;tenant_id&quot;`
    Role        string    `json:&quot;role&quot;`
    Permissions []string  `json:&quot;permissions&quot;`
    IssuedAt    time.Time `json:&quot;iat&quot;`
    ExpiresAt   time.Time `json:&quot;exp&quot;`
    Issuer      string    `json:&quot;iss&quot;`
    Subject     string    `json:&quot;sub&quot;`
    SessionID   string    `json:&quot;session_id&quot;`
    DeviceID    string    `json:&quot;device_id&quot;`
    IPAddress   string    `json:&quot;ip_address&quot;`
    jwt.StandardClaims
}

func validateJWTToken(tokenString string, configObject config.ConfigStruct) (*JWTClaims, error) {
    // Parse JWT token with validation
    token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
        // Validate signing method
        if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
            return nil, fmt.Errorf(&quot;unexpected signing method: %v&quot;, token.Header[&quot;alg&quot;])
        }

        // Load public key for verification
        publicKey, err := loadRSAPublicKey(configObject.JWTPublicKeyPath)
        if err != nil {
            return nil, fmt.Errorf(&quot;failed to load public key: %v&quot;, err)
        }

        return publicKey, nil
    })

    if err != nil {
        return nil, fmt.Errorf(&quot;token parsing failed: %v&quot;, err)
    }

    claims, ok := token.Claims.(*JWTClaims)
    if !ok || !token.Valid {
        return nil, fmt.Errorf(&quot;invalid token claims&quot;)
    }

    // Additional validation checks
    if err := validateTokenClaims(claims); err != nil {
        return nil, fmt.Errorf(&quot;token validation failed: %v&quot;, err)
    }

    // Check token blacklist
    if isTokenBlacklisted(claims.SessionID) {
        return nil, fmt.Errorf(&quot;token has been revoked&quot;)
    }

    // Verify IP address binding (if enabled)
    if configObject.EnableIPBinding &amp;&amp; claims.IPAddress != getClientIP(r) {
        return nil, fmt.Errorf(&quot;token IP address mismatch&quot;)
    }

    return claims, nil
}

// Comprehensive Role-Based Access Control
type Permission struct {
    Resource string `json:&quot;resource&quot;`
    Action   string `json:&quot;action&quot;`
    Scope    string `json:&quot;scope&quot;`
}

type Role struct {
    Name        string       `json:&quot;name&quot;`
    Permissions []Permission `json:&quot;permissions&quot;`
    Inherits    []string     `json:&quot;inherits&quot;`
}

func checkPermissions(userClaims *JWTClaims, resource string, action string, context map[string]interface{}) bool {
    // Load user role and permissions
    userRole := getUserRole(userClaims.Role)
    if userRole == nil {
        return false
    }

    // Check direct permissions
    if hasDirectPermission(userRole, resource, action, context) {
        return true
    }

    // Check inherited permissions
    for _, inheritedRoleName := range userRole.Inherits {
        inheritedRole := getUserRole(inheritedRoleName)
        if inheritedRole != nil &amp;&amp; hasDirectPermission(inheritedRole, resource, action, context) {
            return true
        }
    }

    // Check tenant-specific permissions
    if userClaims.TenantID != &quot;&quot; {
        return hasTenantPermission(userClaims.TenantID, userClaims.UserID, resource, action, context)
    }

    return false
}

// Multi-Tenant Security Context
func createSecurityContext(claims *JWTClaims, request *http.Request) *SecurityContext {
    return &amp;SecurityContext{
        UserID:      claims.UserID,
        TenantID:    claims.TenantID,
        Role:        claims.Role,
        Permissions: claims.Permissions,
        SessionID:   claims.SessionID,
        IPAddress:   getClientIP(request),
        UserAgent:   request.Header.Get(&quot;User-Agent&quot;),
        Timestamp:   time.Now(),
        RequestID:   generateRequestID(),
    }
}
</code></pre>

<h3 id="3-encryption-and-data-protection">3. Encryption and Data Protection<a class="headerlink" href="#3-encryption-and-data-protection" title="Permanent link">&para;</a></h3>
<h4 id="end-to-end-data-encryption">End-to-End Data Encryption<a class="headerlink" href="#end-to-end-data-encryption" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type EncryptionService struct {
    masterKey    []byte
    keyDerivation string
    cipher       string
}

func NewEncryptionService(masterKey []byte) *EncryptionService {
    return &amp;EncryptionService{
        masterKey:     masterKey,
        keyDerivation: &quot;PBKDF2&quot;,
        cipher:        &quot;AES-256-GCM&quot;,
    }
}

func (es *EncryptionService) EncryptData(data []byte, tenantID string) ([]byte, error) {
    // Derive tenant-specific key
    tenantKey := es.deriveTenantKey(tenantID)

    // Generate random nonce
    nonce := make([]byte, 12)
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, err
    }

    // Create AES-GCM cipher
    block, err := aes.NewCipher(tenantKey)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    // Encrypt data
    ciphertext := gcm.Seal(nil, nonce, data, nil)

    // Combine nonce and ciphertext
    encrypted := append(nonce, ciphertext...)

    return encrypted, nil
}

func (es *EncryptionService) DecryptData(encryptedData []byte, tenantID string) ([]byte, error) {
    if len(encryptedData) &lt; 12 {
        return nil, errors.New(&quot;invalid encrypted data&quot;)
    }

    // Extract nonce and ciphertext
    nonce := encryptedData[:12]
    ciphertext := encryptedData[12:]

    // Derive tenant-specific key
    tenantKey := es.deriveTenantKey(tenantID)

    // Create AES-GCM cipher
    block, err := aes.NewCipher(tenantKey)
    if err != nil {
        return nil, err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }

    // Decrypt data
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, err
    }

    return plaintext, nil
}

// Field-Level Database Encryption
func (es *EncryptionService) EncryptField(field string, value interface{}, tenantID string) (string, error) {
    // Serialize value
    data, err := json.Marshal(value)
    if err != nil {
        return &quot;&quot;, err
    }

    // Encrypt data
    encrypted, err := es.EncryptData(data, tenantID)
    if err != nil {
        return &quot;&quot;, err
    }

    // Encode to base64
    return base64.StdEncoding.EncodeToString(encrypted), nil
}
</code></pre>

<h3 id="4-security-monitoring-and-audit-system">4. Security Monitoring and Audit System<a class="headerlink" href="#4-security-monitoring-and-audit-system" title="Permanent link">&para;</a></h3>
<h4 id="comprehensive-audit-logging">Comprehensive Audit Logging<a class="headerlink" href="#comprehensive-audit-logging" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type AuditEvent struct {
    EventID     string                 `json:&quot;event_id&quot;`
    Timestamp   time.Time             `json:&quot;timestamp&quot;`
    UserID      string                `json:&quot;user_id&quot;`
    TenantID    string                `json:&quot;tenant_id&quot;`
    Action      string                `json:&quot;action&quot;`
    Resource    string                `json:&quot;resource&quot;`
    IPAddress   string                `json:&quot;ip_address&quot;`
    UserAgent   string                `json:&quot;user_agent&quot;`
    SessionID   string                `json:&quot;session_id&quot;`
    Result      string                `json:&quot;result&quot;`
    ErrorCode   string                `json:&quot;error_code,omitempty&quot;`
    Details     map[string]interface{} `json:&quot;details&quot;`
    Severity    string                `json:&quot;severity&quot;`
    Category    string                `json:&quot;category&quot;`
    Compliance  []string              `json:&quot;compliance_tags&quot;`
}

type AuditLogger struct {
    database     *mongo.Database
    encryption   *EncryptionService
    retention    time.Duration
    complianceMode bool
}

func (al *AuditLogger) LogSecurityEvent(event *AuditEvent) error {
    // Add automatic fields
    event.EventID = generateEventID()
    event.Timestamp = time.Now().UTC()

    // Encrypt sensitive data
    if al.encryption != nil {
        if err := al.encryptSensitiveFields(event); err != nil {
            return fmt.Errorf(&quot;failed to encrypt audit data: %v&quot;, err)
        }
    }

    // Add compliance tags
    event.Compliance = al.getComplianceTags(event)

    // Store in database
    collection := al.database.Collection(&quot;audit_logs&quot;)
    _, err := collection.InsertOne(context.Background(), event)
    if err != nil {
        return fmt.Errorf(&quot;failed to store audit event: %v&quot;, err)
    }

    // Real-time security monitoring
    if al.isHighRiskEvent(event) {
        go al.triggerSecurityAlert(event)
    }

    return nil
}

// Real-time Security Monitoring
type SecurityMonitor struct {
    alertThresholds map[string]int
    timeWindows     map[string]time.Duration
    alerter         *AlertManager
}

func (sm *SecurityMonitor) MonitorSecurityEvents(events &lt;-chan *AuditEvent) {
    eventCounts := make(map[string]int)

    for event := range events {
        // Track event patterns
        key := fmt.Sprintf(&quot;%s:%s:%s&quot;, event.UserID, event.Action, event.IPAddress)
        eventCounts[key]++

        // Check for suspicious patterns
        if sm.detectSuspiciousActivity(event, eventCounts) {
            alert := &amp;SecurityAlert{
                Type:        &quot;SUSPICIOUS_ACTIVITY&quot;,
                Severity:    &quot;HIGH&quot;,
                Description: &quot;Multiple failed authentication attempts detected&quot;,
                UserID:      event.UserID,
                IPAddress:   event.IPAddress,
                Timestamp:   time.Now(),
                Events:      []string{event.EventID},
            }

            sm.alerter.SendAlert(alert)
        }

        // Check for compliance violations
        if sm.detectComplianceViolation(event) {
            alert := &amp;SecurityAlert{
                Type:        &quot;COMPLIANCE_VIOLATION&quot;,
                Severity:    &quot;CRITICAL&quot;,
                Description: &quot;Data access violation detected&quot;,
                UserID:      event.UserID,
                TenantID:    event.TenantID,
                Timestamp:   time.Now(),
                Events:      []string{event.EventID},
            }

            sm.alerter.SendAlert(alert)
        }
    }
}
</code></pre>

<h3 id="5-network-security-and-rate-limiting">5. Network Security and Rate Limiting<a class="headerlink" href="#5-network-security-and-rate-limiting" title="Permanent link">&para;</a></h3>
<h4 id="advanced-rate-limiting-with-redis">Advanced Rate Limiting with Redis<a class="headerlink" href="#advanced-rate-limiting-with-redis" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type RateLimiter struct {
    redis       *redis.Client
    limits      map[string]RateLimit
    defaultRate RateLimit
}

type RateLimit struct {
    Requests int           `json:&quot;requests&quot;`
    Window   time.Duration `json:&quot;window&quot;`
    Burst    int           `json:&quot;burst&quot;`
}

func (rl *RateLimiter) CheckRateLimit(identifier string, action string) (bool, error) {
    key := fmt.Sprintf(&quot;rate_limit:%s:%s&quot;, identifier, action)

    // Get rate limit configuration
    limit := rl.getLimitForAction(action)

    // Use sliding window log algorithm
    now := time.Now().Unix()
    windowStart := now - int64(limit.Window.Seconds())

    pipe := rl.redis.Pipeline()

    // Remove expired entries
    pipe.ZRemRangeByScore(context.Background(), key, &quot;0&quot;, fmt.Sprintf(&quot;%d&quot;, windowStart))

    // Count current requests
    pipe.ZCard(context.Background(), key)

    // Add current request
    pipe.ZAdd(context.Background(), key, &amp;redis.Z{Score: float64(now), Member: fmt.Sprintf(&quot;%d&quot;, now)})

    // Set expiration
    pipe.Expire(context.Background(), key, limit.Window)

    results, err := pipe.Exec(context.Background())
    if err != nil {
        return false, err
    }

    currentCount := results[1].(*redis.IntCmd).Val()

    // Check if rate limit exceeded
    if int(currentCount) &gt;= limit.Requests {
        // Check burst allowance
        burstKey := fmt.Sprintf(&quot;burst:%s:%s&quot;, identifier, action)
        burstCount, err := rl.redis.Get(context.Background(), burstKey).Int()
        if err == redis.Nil {
            burstCount = 0
        } else if err != nil {
            return false, err
        }

        if burstCount &gt;= limit.Burst {
            return false, nil // Rate limit exceeded
        }

        // Allow burst request
        rl.redis.Incr(context.Background(), burstKey)
        rl.redis.Expire(context.Background(), burstKey, time.Minute)
    }

    return true, nil
}

// DDoS Protection Middleware
func (rl *RateLimiter) DDoSProtectionMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        clientIP := getClientIP(r)
        userAgent := r.Header.Get(&quot;User-Agent&quot;)

        // Check IP-based rate limiting
        allowed, err := rl.CheckRateLimit(clientIP, &quot;global&quot;)
        if err != nil {
            http.Error(w, &quot;Internal Server Error&quot;, http.StatusInternalServerError)
            return
        }

        if !allowed {
            // Log potential DDoS attack
            log.Printf(&quot;Rate limit exceeded for IP: %s, User-Agent: %s&quot;, clientIP, userAgent)

            // Add security headers
            w.Header().Set(&quot;Retry-After&quot;, &quot;60&quot;)
            w.Header().Set(&quot;X-RateLimit-Limit&quot;, &quot;100&quot;)
            w.Header().Set(&quot;X-RateLimit-Remaining&quot;, &quot;0&quot;)

            http.Error(w, &quot;Too Many Requests&quot;, http.StatusTooManyRequests)
            return
        }

        // Add rate limit headers
        remaining, _ := rl.getRemainingRequests(clientIP, &quot;global&quot;)
        w.Header().Set(&quot;X-RateLimit-Limit&quot;, &quot;100&quot;)
        w.Header().Set(&quot;X-RateLimit-Remaining&quot;, fmt.Sprintf(&quot;%d&quot;, remaining))

        next.ServeHTTP(w, r)
    })
}
</code></pre>

<h3 id="6-secure-configuration-management">6. Secure Configuration Management<a class="headerlink" href="#6-secure-configuration-management" title="Permanent link">&para;</a></h3>
<h4 id="configuration-security-framework">Configuration Security Framework<a class="headerlink" href="#configuration-security-framework" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-go">type SecureConfig struct {
    encrypted    map[string]string
    plaintext    map[string]interface{}
    keyService   *KeyManagementService
    validator    *ConfigValidator
}

func LoadSecureConfiguration(configPath string, keyService *KeyManagementService) (*SecureConfig, error) {
    configData, err := ioutil.ReadFile(configPath)
    if err != nil {
        return nil, err
    }

    var rawConfig map[string]interface{}
    if err := json.Unmarshal(configData, &amp;rawConfig); err != nil {
        return nil, err
    }

    config := &amp;SecureConfig{
        encrypted:  make(map[string]string),
        plaintext:  make(map[string]interface{}),
        keyService: keyService,
        validator:  NewConfigValidator(),
    }

    // Process configuration fields
    for key, value := range rawConfig {
        if isSecretField(key) {
            // Decrypt secret fields
            decrypted, err := keyService.Decrypt(value.(string))
            if err != nil {
                return nil, fmt.Errorf(&quot;failed to decrypt %s: %v&quot;, key, err)
            }
            config.encrypted[key] = decrypted
        } else {
            config.plaintext[key] = value
        }
    }

    // Validate configuration
    if err := config.validator.Validate(config); err != nil {
        return nil, fmt.Errorf(&quot;configuration validation failed: %v&quot;, err)
    }

    return config, nil
}

// Environment-Based Security Profiles
type SecurityProfile struct {
    Environment       string              `json:&quot;environment&quot;`
    TLSMinVersion     uint16             `json:&quot;tls_min_version&quot;`
    RequireClientCert bool               `json:&quot;require_client_cert&quot;`
    SessionTimeout    time.Duration      `json:&quot;session_timeout&quot;`
    PasswordPolicy    PasswordPolicy     `json:&quot;password_policy&quot;`
    AuditLevel        string             `json:&quot;audit_level&quot;`
    ComplianceMode    bool               `json:&quot;compliance_mode&quot;`
    EncryptionStrength string            `json:&quot;encryption_strength&quot;`
}

func GetSecurityProfile(environment string) *SecurityProfile {
    profiles := map[string]*SecurityProfile{
        &quot;production&quot;: {
            Environment:       &quot;production&quot;,
            TLSMinVersion:     tls.VersionTLS13,
            RequireClientCert: true,
            SessionTimeout:    time.Hour * 8,
            PasswordPolicy:    StrictPasswordPolicy,
            AuditLevel:        &quot;FULL&quot;,
            ComplianceMode:    true,
            EncryptionStrength: &quot;AES-256&quot;,
        },
        &quot;development&quot;: {
            Environment:       &quot;development&quot;,
            TLSMinVersion:     tls.VersionTLS12,
            RequireClientCert: false,
            SessionTimeout:    time.Hour * 24,
            PasswordPolicy:    BasicPasswordPolicy,
            AuditLevel:        &quot;BASIC&quot;,
            ComplianceMode:    false,
            EncryptionStrength: &quot;AES-128&quot;,
        },
    }

    if profile, exists := profiles[environment]; exists {
        return profile
    }

    // Default to production profile for unknown environments
    return profiles[&quot;production&quot;]
}
</code></pre>

<hr />
<p><em>Document Version: 2.0</em><br />
<em>Last Updated: October 6, 2025</em><br />
<em>Author: Development Team</em><br />
<em>Classification: Confidential - Internal Use Only</em></p>
    </main>

    <footer class="footer">
        <p>&copy; 2025 Securaa Security Platform. All rights reserved.</p>
        <p>Documentation generated on December 04, 2025</p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#4f46e5',
                primaryTextColor: '#1f2937',
                primaryBorderColor: '#818cf8',
                lineColor: '#6b7280',
                secondaryColor: '#f3f4f6',
                tertiaryColor: '#e5e7eb',
                background: '#ffffff',
                mainBkg: '#f9fafb',
                secondBkg: '#f3f4f6',
                border1: '#e5e7eb',
                border2: '#d1d5db',
                fontFamily: 'Inter, sans-serif',
                fontSize: '14px',
                nodeBorder: '#4f46e5',
                clusterBkg: '#f0f4f8',
                clusterBorder: '#818cf8',
                edgeLabelBackground: '#ffffff'
            },
            flowchart: {
                htmlLabels: true,
                useMaxWidth: true,
                curve: 'basis',
                padding: 15,
                nodeSpacing: 50,
                rankSpacing: 50
            },
            sequence: {
                actorMargin: 50,
                width: 150,
                height: 65,
                boxMargin: 10,
                boxTextMargin: 5,
                noteMargin: 10,
                messageMargin: 35,
                mirrorActors: true,
                useMaxWidth: true
            },
            er: {
                useMaxWidth: true,
                entityPadding: 15,
                fontSize: 12
            },
            class: {
                useMaxWidth: true,
                padding: 10
            },
            gantt: {
                useMaxWidth: true,
                barHeight: 20,
                barGap: 4,
                topPadding: 50,
                leftPadding: 75
            },
            pie: {
                useMaxWidth: true,
                textPosition: 0.5
            },
            mindmap: {
                useMaxWidth: true,
                padding: 10
            },
            securityLevel: 'loose',
            logLevel: 'error'
        });

        // Re-render mermaid diagrams after page load for better sizing
        window.addEventListener('load', function() {
            setTimeout(function() {
                document.querySelectorAll('.mermaid').forEach(function(el) {
                    if (el.getAttribute('data-processed') !== 'true') {
                        mermaid.init(undefined, el);
                    }
                });
            }, 100);
        });
    </script>
</body>
</html>
